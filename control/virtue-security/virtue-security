#!/usr/local/bin/python
__VERSION__ = "1"

from aiohttp import web, ClientSession
from aiohttp.client_exceptions import ClientConnectionError
import argparse
import asyncio
import base64
from contextlib import closing
from Crypto.PublicKey import RSA
import datetime
import http
import json
import kafka
import os
import pytimeparse
import pytz
import random
import re
import requests
import ssl
import socket
import sys
import uuid



def fuzzing_from_blns():
    """
    What a wonderful resource [The Big List of Naughty Strings](https://github.com/minimaxir/big-list-of-naughty-strings)
    is. This method will return a random string from a subset of this list that is useful
    for URI/query param fuzzing.

    I would really, seriously recommend you not edit this function. I would also collapse this function in
    your editor if at all possible, as most layout engines go a bit bonkers trying to update this
    section. Also, your syntax hinting for a few lines after this function may be unreliable.

    :return: String
    """
    warm_fuzzies_from_blns = [
	"undefined","undef","null","NULL","(null)","nil","NIL","true","false","True",
	"False","TRUE","FALSE","None","hasOwnProperty","0","1","1.00","$1.00","1/2",
	"1E2","1E02","1E+02","-1","-1.00","-$1.00","-1/2","-1E2","-1E02","-1E+02",
	"1/0","0/0","-2147483648/-1","-9223372036854775808/-1","-0","-0.0","+0",
	"+0.0","0.00","0..0",".","0.0.0","0,00","0,,0",",","0,0,0","0.0/0","1.0/0.0",
	"0.0/0.0","1,0/0,0","0,0/0,0","--1","-","-.","-,",
	"999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
	"NaN","Infinity","-Infinity","INF","1#INF","-1#IND","1#QNAN","1#SNAN",
	"1#IND","0x0","0xffffffff","0xffffffffffffffff","0xabad1dea",
	"123456789012345678901234567890123456789","1,000.00","1 000.00","1'000.00",
	"1,000,000.00","1 000 000.00","1'000'000.00","1.000,00","1 000,00","1'000,00",
	"1.000.000,00","1 000 000,00","1'000'000,00","01000","08","09",
	"2.2250738585072011e-308",",./;'[]\-=","<>?:{}|_+","!@#$%^&*()`~",
	"",
	"Â€ÂÂ‚ÂƒÂ„Â†Â‡ÂˆÂ‰ÂŠÂ‹ÂŒÂÂŽÂÂÂ‘Â’Â“Â”Â•Â–Â—Â˜Â™ÂšÂ›ÂœÂÂžÂŸ","	 Â… áš€â€€â€â€‚â€ƒâ€„â€…â€†â€‡â€ˆâ€‰â€Šâ€‹â€¨â€©â€¯âŸã€€",
	"Â­Ø€ØØ‚ØƒØ„Ø…ØœÛÜá Žâ€‹â€Œâ€â€Žâ€â€ªâ€«â€¬â€­â€®â â¡â¢â£â¤â¦â§â¨â©âªâ«â¬â­â®â¯ï»¿ï¿¹ï¿ºï¿»ð‘‚½ð›² ð›²¡ð›²¢ð›²£ð…³ð…´ð…µð…¶ð…·ð…¸ð…¹ð…ºó €ó € ó €¡ó €¢ó €£ó €¤ó €¥ó €¦ó €§ó €¨ó €©ó €ªó €«ó €¬ó €­ó €®ó €¯ó €°ó €±ó €²ó €³ó €´ó €µó €¶ó €·ó €¸ó €¹ó €ºó €»ó €¼ó €½ó €¾ó €¿ó €ó ó ‚ó ƒó „ó …ó †ó ‡ó ˆó ‰ó Šó ‹ó Œó ó Žó ó ó ‘ó ’ó “ó ”ó •ó –ó —ó ˜ó ™ó šó ›ó œó ó žó Ÿó  ó ¡ó ¢ó £ó ¤ó ¥ó ¦ó §ó ¨ó ©ó ªó «ó ¬ó ­ó ®ó ¯ó °ó ±ó ²ó ³ó ´ó µó ¶ó ·ó ¸ó ¹ó ºó »ó ¼ó ½ó ¾ó ¿","Î©â‰ˆÃ§âˆšâˆ«ËœÂµâ‰¤â‰¥Ã·",
	"Ã¥ÃŸâˆ‚Æ’Â©Ë™âˆ†ËšÂ¬â€¦Ã¦","Å“âˆ‘Â´Â®â€ Â¥Â¨Ë†Ã¸Ï€â€œâ€˜","Â¡â„¢Â£Â¢âˆžÂ§Â¶â€¢ÂªÂºâ€“â‰ ","Â¸Ë›Ã‡â—ŠÄ±ËœÃ‚Â¯Ë˜Â¿","Ã…ÃÃŽÃËÃ“Ã”ï£¿Ã’ÃšÃ†â˜ƒ",
	"Å’â€žÂ´â€°Ë‡ÃÂ¨Ë†Ã˜âˆâ€â€™","`â„â‚¬â€¹â€ºï¬ï¬‚â€¡Â°Â·â€šâ€”Â±","â…›â…œâ…â…ž",
	"ÐÐ‚ÐƒÐ„Ð…Ð†Ð‡ÐˆÐ‰ÐŠÐ‹ÐŒÐÐŽÐÐÐ‘Ð’Ð“Ð”Ð•Ð–Ð—Ð˜Ð™ÐšÐ›ÐœÐÐžÐŸÐ Ð¡Ð¢Ð£Ð¤Ð¥Ð¦Ð§Ð¨Ð©ÐªÐ«Ð¬Ð­Ð®Ð¯Ð°Ð±Ð²Ð³Ð´ÐµÐ¶Ð·Ð¸Ð¹ÐºÐ»Ð¼Ð½Ð¾Ð¿Ñ€ÑÑ‚ÑƒÑ„Ñ…Ñ†Ñ‡ÑˆÑ‰ÑŠÑ‹ÑŒÑÑŽÑ",
	"Ù Ù¡Ù¢Ù£Ù¤Ù¥Ù¦Ù§Ù¨Ù©","â°â´âµ","â‚€â‚â‚‚","â°â´âµâ‚€â‚â‚‚","à¸”à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡ à¸”à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡ à¸”à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡à¹‡à¹‰à¹‰à¹‰à¹‰à¹‰à¹‡à¹‡à¹‡à¹‡","ç”°ä¸­ã•ã‚“ã«ã‚ã’ã¦ä¸‹ã•ã„",
	"ãƒ‘ãƒ¼ãƒ†ã‚£ãƒ¼ã¸è¡Œã‹ãªã„ã‹","å’Œè£½æ¼¢èªž","éƒ¨è½æ ¼","ì‚¬íšŒê³¼í•™ì› ì–´í•™ì—°êµ¬ì†Œ",
	"ì°¦ì°¨ë¥¼ íƒ€ê³  ì˜¨ íŽ²ì‹œë§¨ê³¼ ì‘›ë‹¤ë¦¬ ë˜ ë°©ê°í•˜","ç¤¾æœƒç§‘å­¸é™¢èªžå­¸ç ”ç©¶æ‰€","ìš¸ëž€ë°”í† ë¥´","ð œŽð œ±ð ¹ð ±“ð ±¸ð ²–ð ³",
	"Èº","È¾","ãƒ½à¼¼àºˆÙ„Íœàºˆà¼½ï¾‰ ãƒ½à¼¼àºˆÙ„Íœàºˆà¼½ï¾‰","(ï½¡â—• âˆ€ â—•ï½¡)","ï½€ï½¨(Â´âˆ€ï½€âˆ©","__ï¾›(,_,*)",
	"ãƒ»(ï¿£âˆ€ï¿£)ãƒ»:*:","ï¾Ÿï½¥âœ¿ãƒ¾â•²(ï½¡â—•â€¿â—•ï½¡)â•±âœ¿ï½¥ï¾Ÿ",",ã€‚ãƒ»:*:ãƒ»ã‚œâ€™( â˜» Ï‰ â˜» )ã€‚ãƒ»:*:ãƒ»ã‚œâ€™",
	"(â•¯Â°â–¡Â°ï¼‰â•¯ï¸µ â”»â”â”»)","(ï¾‰à²¥ç›Šà²¥ï¼‰ï¾‰ï»¿ â”»â”â”»","â”¬â”€â”¬ãƒŽ( Âº _ ÂºãƒŽ)","( Í¡Â° ÍœÊ– Í¡Â°)",
	"ðŸ˜","ðŸ‘©ðŸ½","ðŸ‘¾ ðŸ™‡ ðŸ’ ðŸ™… ðŸ™† ðŸ™‹ ðŸ™Ž ðŸ™","ðŸµ ðŸ™ˆ ðŸ™‰ ðŸ™Š",
	"â¤ï¸ ðŸ’” ðŸ’Œ ðŸ’• ðŸ’ž ðŸ’“ ðŸ’— ðŸ’– ðŸ’˜ ðŸ’ ðŸ’Ÿ ðŸ’œ ðŸ’› ðŸ’š ðŸ’™","âœ‹ðŸ¿ ðŸ’ªðŸ¿ ðŸ‘ðŸ¿ ðŸ™ŒðŸ¿ ðŸ‘ðŸ¿ ðŸ™ðŸ¿",
	"ðŸš¾ ðŸ†’ ðŸ†“ ðŸ†• ðŸ†– ðŸ†— ðŸ†™ ðŸ§","0ï¸âƒ£ 1ï¸âƒ£ 2ï¸âƒ£ 3ï¸âƒ£ 4ï¸âƒ£ 5ï¸âƒ£ 6ï¸âƒ£ 7ï¸âƒ£ 8ï¸âƒ£ 9ï¸âƒ£ ðŸ”Ÿ",
	"ï¼‘ï¼’ï¼“","Ù¡Ù¢Ù£",
"Ø«Ù… Ù†ÙØ³ Ø³Ù‚Ø·Øª ÙˆØ¨Ø§Ù„ØªØ­Ø¯ÙŠØ¯ØŒ, Ø¬Ø²ÙŠØ±ØªÙŠ Ø¨Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø£Ù† Ø¯Ù†Ùˆ. Ø¥Ø° Ù‡Ù†Ø§ØŸ Ø§Ù„Ø³ØªØ§Ø± ÙˆØªÙ†ØµÙŠØ¨ ÙƒØ§Ù†. Ø£Ù‡Ù‘Ù„ Ø§ÙŠØ·Ø§Ù„ÙŠØ§ØŒ Ø¨Ø±ÙŠØ·Ø§Ù†ÙŠØ§-ÙØ±Ù†Ø³Ø§ Ù‚Ø¯ Ø£Ø®Ø°. Ø³Ù„ÙŠÙ…Ø§Ù†ØŒ Ø¥ØªÙØ§Ù‚ÙŠØ© Ø¨ÙŠÙ† Ù…Ø§, ÙŠØ°ÙƒØ± Ø§Ù„Ø­Ø¯ÙˆØ¯ Ø£ÙŠ Ø¨Ø¹Ø¯, Ù…Ø¹Ø§Ù…Ù„Ø© Ø¨ÙˆÙ„Ù†Ø¯Ø§ØŒ",
	"×”Ö¸×™Ö°×ªÖ¸×”testØ§Ù„ØµÙØ­Ø§Øª Ø§Ù„ØªÙ‘Ø­ÙˆÙ„",
"ï·½",
"ï·º",
"Ù…ÙÙ†ÙŽØ§Ù‚ÙŽØ´ÙŽØ©Ù Ø³ÙØ¨ÙÙ„Ù Ø§ÙØ³Ù’ØªÙØ®Ù’Ø¯ÙŽØ§Ù…Ù Ø§Ù„Ù„Ù‘ÙØºÙŽØ©Ù ÙÙÙŠ Ø§Ù„Ù†Ù‘ÙØ¸ÙÙ…Ù Ø§Ù„Ù’Ù‚ÙŽØ§Ø¦ÙÙ…ÙŽØ©Ù ÙˆÙŽÙÙÙŠÙ… ÙŠÙŽØ®ÙØµÙ‘ÙŽ Ø§Ù„ØªÙ‘ÙŽØ·Ù’Ø¨ÙÙŠÙ‚ÙŽØ§ØªÙ Ø§Ù„Ù’Ø­Ø§Ø³ÙÙˆØ¨ÙÙŠÙ‘ÙŽØ©ÙØŒ ",
	"â€ªâ€ªtestâ€ª","â€«testâ€«","â€©testâ€©","testâ testâ€«","â¦testâ§",
	"Ë™Énbá´‰lÉ ÉuÆƒÉÉ¯ ÇÉ¹olop Ê‡Ç ÇÉ¹oqÉl Ê‡n Ê‡unpá´‰pá´‰É”uá´‰ É¹odÉ¯ÇÊ‡ poÉ¯sná´‰Ç op pÇs 'Ê‡á´‰lÇ Æƒuá´‰É”sá´‰dá´‰pÉ É¹nÊ‡ÇÊ‡É”ÇsuoÉ” 'Ê‡ÇÉ¯É Ê‡á´‰s É¹olop É¯nsdá´‰ É¯ÇÉ¹oË¥",
	"00Ë™Æ–$-","ï¼´ï½ˆï½… ï½‘ï½•ï½‰ï½ƒï½‹ ï½‚ï½’ï½ï½—ï½Ž ï½†ï½ï½˜ ï½Šï½•ï½ï½ï½“ ï½ï½–ï½…ï½’ ï½”ï½ˆï½… ï½Œï½ï½šï½™ ï½„ï½ï½‡",
	"ð“ð¡ðž ðªð®ð¢ðœð¤ ð›ð«ð¨ð°ð§ ðŸð¨ð± ð£ð®ð¦ð©ð¬ ð¨ð¯ðžð« ð­ð¡ðž ð¥ðšð³ð² ðð¨ð ","ð•¿ð–ð–Š ð––ð–šð–Žð–ˆð– ð–‡ð–—ð–”ð–œð–“ ð–‹ð–”ð– ð–ð–šð–’ð–•ð–˜ ð–”ð–›ð–Šð–— ð–™ð–ð–Š ð–‘ð–†ð–Ÿð–ž ð–‰ð–”ð–Œ",
	"ð‘»ð’‰ð’† ð’’ð’–ð’Šð’„ð’Œ ð’ƒð’“ð’ð’˜ð’ ð’‡ð’ð’™ ð’‹ð’–ð’Žð’‘ð’” ð’ð’—ð’†ð’“ ð’•ð’‰ð’† ð’ð’‚ð’›ð’š ð’…ð’ð’ˆ",
	"ð“£ð“±ð“® ð“ºð“¾ð“²ð“¬ð“´ ð“«ð“»ð“¸ð”€ð“· ð“¯ð“¸ð” ð“³ð“¾ð“¶ð“¹ð“¼ ð“¸ð“¿ð“®ð“» ð“½ð“±ð“® ð“µð“ªð”ƒð”‚ ð“­ð“¸ð“°","ð•‹ð•™ð•– ð•¢ð•¦ð•šð•”ð•œ ð•“ð•£ð• ð•¨ð•Ÿ ð•—ð• ð•© ð•›ð•¦ð•žð•¡ð•¤ ð• ð•§ð•–ð•£ ð•¥ð•™ð•– ð•ð•’ð•«ð•ª ð••ð• ð•˜",
	"ðšƒðš‘ðšŽ ðššðšžðš’ðšŒðš” ðš‹ðš›ðš˜ðš ðš— ðšðš˜ðš¡ ðš“ðšžðš–ðš™ðšœ ðš˜ðšŸðšŽðš› ðšðš‘ðšŽ ðš•ðšŠðš£ðš¢ ðšðš˜ðš",
	"â’¯â’£â’  â’¬â’°â’¤â’žâ’¦ â’â’­â’ªâ’²â’© â’¡â’ªâ’³ â’¥â’°â’¨â’«â’® â’ªâ’±â’ â’­ â’¯â’£â’  â’§â’œâ’µâ’´ â’Ÿâ’ªâ’¢",
	"1;DROP TABLE users","1'; DROP TABLE users-- 1","' OR 1=1 -- 1",
	"' OR '1'='1 ","%","_","-","--","--version","--help",
	"$USER","/dev/null; touch /tmp/blns.fail ; echo","`touch /tmp/blns.fail`","$(touch /tmp/blns.fail)",
	"$HOME","$ENV{'HOME'}","%d","%s","{0}","%*.*s","File:///",
	"../../../../../../../../../../../etc/passwd%00",
	"../../../../../../../../../../../etc/hosts",
	"() { 0; }; touch /tmp/blns.shellshock1.fail;",
	"() { _; } >_[$($())] { touch /tmp/blns.shellshock2.fail; }",
	"<<< %s(un='%s') = %u","+++ATH0","DCC SEND STARTKEYLOGGER 0 0 0",
	"PowerÙ„ÙÙ„ÙØµÙ‘Ø¨ÙÙ„ÙÙ„ØµÙ‘Ø¨ÙØ±Ø±Ù‹ à¥£ à¥£h à¥£ à¥£å†—","ðŸ³0ðŸŒˆï¸"]

    return random.choice(warm_fuzzies_from_blns)


def test_generate_user_token():
    """
    Just generate a junk authentication token for test purposes.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_application():
    """
    For identifying applications we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_application_fuzz():
    """
    Create fuzzing values for the Application ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_resource():
    """
    For identifying resources, we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_resource_fuzz():
    """
    Create fuzzing values for the Resource ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_sensor():
    """
    For identifying a specific sensor, we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_sensor_fuzz():
    """
    Create fuzzing values for the Sensor ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_username():
    """
    Generate a basic username.

    :return: String
    """
    return ".".join(random.sample("Aaden Alaysia Alfred Amia Annabell Anson Apollo Araceli Astrid Audrianna Augustine Avalyn Ayana Bayleigh Belinda Branden Brendon Brenton Broderick Brysen Camilo Camryn Castiel Charity Clyde Collins Corban Cristina Dalilah Darien Dario Davon Deegan Denzel Devyn Emmaline Ephraim Estelle Giovanna Graeme Grey Houston Immanuel India Ireland Jakobe Jaycob Jayde Jayse Jordy Judith Kaidence Kailani Kaiya Kalel Kannon Karissa Karly Karma Kaylyn Kenna Kohen Kylah Lachlan Langston Leroy Lillyana Magnolia Magnus Makena Marleigh Meadow Nahla Natalya Neriah Osvaldo Penny Pierre Princess Reagan Rihanna Rivka Rocky Rowen Roxanne Ryann Santana Sarahi Sidney Tamia Tess Thatcher Tinley Todd Truman Tyree Tyrell Yadiel Yair Zainab".split(" "), 2))


def test_parameter_username_fuzz():
    """
    Create fuzzing values for the Username. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_since():
    """
    A time stamp as a filter value for the **since** parameter
    in a time based or time series query. Defaults to NOW

    :return: String
    """
    return datetime.datetime.now(tz=pytz.utc).isoformat()


def test_parameter_since_fuzz():
    """
    Create fuzzing values for the Since timestamp. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_validate_action():
    """
    Action taken during sensor validation.

    :return: String
    """
    return random.choice(["canary", "cross-validation"])


def test_parameter_validate_action_fuzz():
    """
    Create fuzzing values for the sensor validation action. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_filter_level():
    """
    Filter level is used to control filtering of log messages. This
    value is from a set of default terms:

        ["everything", "debug", "info", "warning", "error", "event"]

    or from either of the terms:

        INC
        DEC

    :return:
    """
    return random.choice(["everything", "debug", "info", "warning", "error", "event"])


def test_parameter_filter_level_fuzz():
    """
    Create fuzzing values for the Filter level. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_follow():
    """
    Parameter for following (or not) a JSONL series from the log
    streamer.

    :return: True or False
    """
    return random.choice([True, False])


def test_parameter_follow_fuzz():
    """
    Create fuzzing values for the Follow. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_action():
    """
    Our test parameters.

    :return: String
    """
    return random.choice(["validate", "invalidate"])


def test_parameter_action_fuzz():
    """
    Create fuzzing values for the action. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_cidr():
    """
    Build a test parameter value for a CIDR block. This needs to be an
    IP plus a suffix filter, like 8.0.0.0/27. We'll auto-escape the slash
    as %2F

    This will, for now, return a random IP in the range 2.0.0.0-240.0.0.0

    :return: IPv4 IP as a String
    """
    return "%d.%d.%d.%d%%2F%d" % (
        random.randint(2, 240),
        random.randint(1, 255),
        random.randint(1, 255),
        random.randint(2, 250),
        random.randint(8, 32)
    )


def test_parameter_cidr_fuzz():
    """
    Create fuzzing values for the Application ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_address():
    """
    An address is a hostname or IPv4 address that describes a
    single host. We randomly select among these.

    :return: String address
    """
    if random.choice([1, 2]) == 1:
        # IPv4 it is
        return "%d.%d.%d.%d" % (
            random.randint(2, 240),
            random.randint(1, 255),
            random.randint(1, 255),
            random.randint(2, 250)
        )
    else:
        # Hostname. Let's make something AWS like
        return "ip-%d-%d-%d-%d.us-%s-%d.compute.internal" % (
            random.randint(2, 240),
            random.randint(1, 255),
            random.randint(1, 255),
            random.randint(2, 250),
            random.choice(["east", "west"]),
            random.randint(1,3)
        )


def test_parameter_address_fuzz():
    """
    Create fuzzing values for the Address. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_hostname():
    """
    Just a hostname, similar to the hostnames generated by
    test_parameter_address.

    :return: String hostname
    """
    # Hostname. Let's make something AWS like
    return "ip-%d-%d-%d-%d.us-%s-%d.compute.internal" % (
        random.randint(2, 240),
        random.randint(1, 255),
        random.randint(1, 255),
        random.randint(2, 250),
        random.choice(["east", "west"]),
        random.randint(1, 3)
    )


def test_parameter_hostname_fuzz():
    """
    Create fuzzing values for the Hostname. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # pull from BLNS
    return fuzzing_from_blns()


def test_parameter_port():
    """
    Return a valid port value, as a string. Our ports are in
    the range of 2000-64000

    :return: Port number as integer
    """
    return random.randint(2000, 64000)


def test_parameter_port_fuzz():
    """
    Let's create fuzzing values for the port. Just like
    everything else we'll pull for BLNS for now.

    :return:
    """
    return fuzzing_from_blns()


def test_parameter_virtue():
    """
    Generate a VirtueID, which is a UUID.

    :return: Random UUID as String
    """
    return str(uuid.uuid4())


def test_parameter_virtue_fuzz():
    """
    Create fuzzing values for the Application ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_level():
    """
    Build a test parameter value for the LEVEL at which a sensor
    or group of sensors can observe. Will be one of:

        off, default, low, high, adversarial

    :return:
    """
    return random.choice("off default low high adversarial".split(" "))


def test_parameter_level_fuzz():
    """
    Create fuzzing values for the Application ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_uri_has_parameters(uri):
    """
    Determine if the test URI has parameters we know how to parse and
    interpolate. This will throw an exception if we find a parameter
    we don't know how to deal with.

    Parameters in URIs look like:

        /path/to/:id/and/:another

    Where :id and :another are named parameters.

    :param uri:
    :return: True or False
    """
    bits = uri.split("/")
    while len(bits[0]) == 0:
        bits = bits[1:]

    params = [bit for bit in bits if bit[0] == ":"]

    if len(params) == 0:
        return False
    else:

        # make sure all of the params have known functions
        for param in params:
            try:
                param_func = "test_parameter_%s" % (param[1:],)
                eval(param_func)
            except NameError as ne:
                # it doesn't exist, let's throw an error here
                print("uri [%s] contains a named parameter we can't interpolate [%s]" % (uri, param))
                raise ne
        return True


def test_interpolate_uri_parameters(uri_path):
    """
    Build the test URI given possible parameters.

    :param uri: String path for the URI
    :return:
    """


    if test_uri_has_parameters(uri_path):
        selected_params = {}
        bits = uri_path.split("/")
        new_bits = []

        # clean off leading slashes
        while len(bits[0]) == 0:
            bits = bits[1:]

        # do interpolations
        for bit in bits:
            if bit[0] == ":":
                # we got a param!
                new_bits.append(test_interpolate_parameter(bit))
                selected_params[bit] = new_bits[-1]
            else:
                # not a param
                new_bits.append(bit)

        # rebuild the path
        return "/%s" % ("/".join(new_bits),), selected_params
    else:
        return uri_path, {}


def test_interpolate_parameter(bit):
    """
    Given a named parameter, built a real value for it. This uses
    the `test_parameter_*` functions to get a random value.

    :param bit: Named parameter starting with a ':'
    :return: Real value
    """
    func = eval("test_parameter_%s" % (bit[1:],))
    return func()


def test_interpolate_request_body(body_dict):
    """
    Given a dictionary of a body request, interpolate any values that are
    functions, and return the newly generated data. Values that aren't
    functions will be returned as literals

    :param body_dict: K/v dictionary
    :return:
    """
    new_body = {}

    for k, v in body_dict.items():
        if callable(v):
            new_body[k] = v()
        else:
            new_body[k] = v
    return new_body


def test_interpolate_parameters(test):
    """
    Interpolate possible parameters for a GET based request. This uses
    any values in the *parameters* section of a test case, as well as
    testing for authentication. The return value is a dictionary of
    request parameters

    :param test: Test Case definition
    :return: Dictionary of parameters
    """
    tups = []

    if "authenticate" in test and test["authenticate"]:
        tups.append(("userToken", test_generate_user_token()))

    if "parameters" in test:
        for parameter in test["parameters"]:

            # try and find a test_parameter function for this value
            try:
                func = eval("test_parameter_%s" % (parameter,))
            except NameError as ne:
                print("TestCase has a parameter that we can't interpolate [%s]" % (parameter,))
                raise ne

            # add a value

            # if our value is a boolean, we need to translate it to a string
            val = func()
            if is_boolean(val):
                val = str(val)

            tups.append((parameter, val))

    return {tup[0]: tup[1] for tup in tups}


def validate_is_one_of(*kargs):
    """
    Given two lists of validators, make sure one
    or the other passes.

    :param kargs:
    :return:
    """

    def validate_is_one_of_inner(results):
        vnames = []

        for validators in kargs:
            errors = []
            for validator in validators:
                vnames.append(validator.__name__)
                errors += validator(results)
            if len(errors) == 0:
                return []

        # we need to return the whole list of validators
        return ["Failed validator %s" % (vname,) for vname in vnames]

    return validate_is_one_of_inner


def validate_isnt_error(results):
    """
    Validate that the given results have no errors.

    :param results: parsed JSON object
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "error": is_exactly(False),
        "timestamp": is_timestamp
    }

    return run_validation(results, check_for)


def validate_is_error(results):
    """
    Validate that the given results have the elements
    required for an error condition:

        error: True
        msg: String
        timestamp:

    :param results: parsed JSON object
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_exactly(True),
        "msg": is_string,
        "timestamp": is_timestamp
    }

    return run_validation(results, check_for)


def validate_stream_message(results):
    """
    Validate that our result contains a streaming log
    message, which has the fomr:

        {
            "error": False,
            "timestamp": timestamp,
            "log_level": one of ["everything", "debug", "info", "warning", "error", "event"],
            "sensor": uuid(),
            "message": log message
        }

    :param results: Parsed result of a single JSON line from a JSONL response from a /stream REST API call
    :return: List of errors, empty list if no errors
    """
    check_for = {
        "error": is_boolean,
        "timestamp": is_timestamp,
        "log_level": is_in("everything", "debug", "info", "warning", "error", "event"),
        "sensor": is_uuid,
        "message": is_string
    }

    return run_validation(results, check_for)


def validate_observe(results):
    """
    Validate the results form an /observe Sensing API
    call. The response object looks like:

        {
            "error": False,
            "level": sensing level,
            "timestamp": timestamp,
            "targeting": {},
            "actions": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "level": ( off | default | low | high | adversarial)
                },
                ...
            ]
        }

    :param results: Parsed results of /observe API call
    :return: List of errors, empty list if no errors
    """

    check_outer = {
        "error": is_boolean,
        "level": is_in("off", "default", "low", "high", "adversarial"),
        "timestamp": is_timestamp,
        "targeting": is_targeting
    }

    check_actions = {
        "sensor": is_uuid,
        "virtue": is_uuid,
        "level": is_in("off", "default", "low", "high", "adversarial")
    }

    errors = run_validation(results, check_outer)

    if "actions" in results:
        for action in results["actions"]:
            errors += run_validation(action, check_actions)
    else:
        errors.append("Missing [actions] in observe results")

    return errors


def validate_trust_invalidate(results):
    """
    Validate the results from a trust/invalidate Sensing API
    call. The response object looks like:

        {
            "error": False,
            "targeting": {},
            "timestamp": timestamp,
            "action": "invalidate",
            "invalidations": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "certificate": {
                        "cn": uuid,
                        "fingerprint": "08:3F:... 32 times"
                    }
                },
                ...
            ]
        }

    :param results: Parsed results of trust/invalidate API call
    :return: List of errors, emtpy list for no errors
    """
    errors = []

    check_for_outer = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp,
        "action": is_in("invalidate")
    }

    check_for_inner = {
        "sensor": is_uuid,
        "virtue": is_uuid
    }

    check_for_cert = {
        "cn": has_value,
        "fingerprint": is_fingerprint,
    }

    # check the outer block of results
    errors += run_validation(results, check_for_outer)

    # now check all the validations
    if "invalidations" in results:
        for validation in results["invalidations"]:

            # validation block
            errors += run_validation(validation, check_for_inner)

            # certificate block
            if "certificate" in validation:
                errors += run_validation(validation["certificate"], check_for_cert)
            else:
                errors.append("Invalidation is missing [certificate] data")
    else:
        errors.append("Missing [invalidations] in results")

    return errors


def validate_trust_validate(results):
    """
    Validate the results from a trust/validate Sensing API
    call. The response object looks like:

        {
            "error": False,
            "targeting": {},
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "action": "validate",
            "validations": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "certificate": {
                        "not_valid_before": timestamp,
                        "not_valid_after": timestamp,
                        "CN": "sensor-name-and-id",
                        "key_type": "RSA Public Key (4096 bit)",
                        "fingerprint": "08:3F:.... 32 octets",
                        "chain_of_trust": ["intermediate-cert-1", ... , "root-cert"]
                    }
                }
            ]
        }

    :param results: Parsed results from a trust/validate REST JSON response
    :return: List of errors, empty list for no errors
    """

    errors = []

    check_for_outer = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp,
        "action": is_in("validate")
    }

    check_for_inner = {
        "sensor": is_uuid,
        "virtue": is_uuid
    }

    check_for_cert = {
        "not_valid_before": is_timestamp,
        "not_valid_after": is_timestamp,
        "cn": has_value,
        "key_type": is_exactly("RSA Public Key (4096 bit)"),
        "fingerprint": is_fingerprint,
        "chain_of_trust": each_item(is_string)
    }

    # check the outer block of results
    errors += run_validation(results, check_for_outer)

    # now check all the validations
    if "validations" in results:
        for validation in results["validations"]:

            # validation block
            errors += run_validation(validation, check_for_inner)

            # certificate block
            if "certificate" in validation:
                errors += run_validation(validation["certificate"], check_for_cert)
            else:
                errors.append("Validation is missing [certificate] data")
    else:
        errors.append("Missing [validations] in results")

    return errors


def validate_inspect(results):
    """
    Validate the results from a sensor set inspection call. This
    targets zero or more sensors, and has a response that looks
    like:

        {
            "error": False,
            "targeting": {},
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "sensors": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "state": (active | inactive),
                    "name": string
                },
                ...
            ]
        }

    :param results: Parsed results from an /inspect REST JSON response
    :return: List of errors, empty list for no errors
    """

    # check the top level object
    check_for = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp
    }

    errors = run_validation(results, check_for)

    # now get errors for any of the sensors
    sensor_check_for = {
        "sensor": is_uuid,
        "virtue": is_uuid,
        "state": is_in("active", "inactive"),
        "name": is_string
    }

    if "sensors" in results:
        for sensor in results["sensors"]:
            errors += run_validation(sensor, sensor_check_for)
    else:
        errors.append("No [sensor] data in inspect results")
    return errors


def validate_configure_review(results):
    """
    Validate the results from a configuration review
    call. This targets a specific sensor, and has
    a response that looks like:

        {
            "error": False,
            "sensor": uuid,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "configuration": {}
        }

    :param results: Parsed results from a configure/review REST JSON response
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_boolean,
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "configuration": is_dict
    }

    return run_validation(results, check_for)


def validate_configure_update(results):
    """
    Validate the results from a configuration update for
    a sensor. This targets a specific sensor, and has
    a response that looks like:

        {
            "error": False,
            "sensor": uuid,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "config_source": ( uri | base64 ),
            "msg": "ok"
        }

    :param results: Parse results from a configure/update REST JSON response
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_boolean,
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "config_source": is_in("uri", "base64"),
        "msg": is_in("ok")
    }

    return run_validation(results, check_for)


def validate_trigger_validation(results):
    """
    Validate the results from triggering a _validate/trigger_ call
    into the Sensing API. The results will look something like:

        {
            "error": False,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "token": uuid,
            "validation": <cross-validate || canary-validate>,
            "virtues": [ ... uuid ...]
        }

    :param results: Parsed results from a */validate/:action REST JSON response
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "error": is_boolean,
        "timestamp": is_timestamp,
        "token": is_uuid,
        "validation": is_in("canary-validate", "cross-validate"),
        "virtues": each_item(is_uuid),
        "targeting": is_targeting
    }

    return run_validation(results, check_for)


def validate_sensor_validation_list(results):
    """
    Validate the list of sensors as returned from a _validate/check_ call
    into the Sensing API. The results will look something like:

        {
            "timestamp": "",
            "error": False,
            "targeting": {},
            "sensors": [
                {
                    "virtue": uuid,
                    "sensor": uuid,
                    "name": "",
                    "last-validated": "2017-10-31 20:40:28.190581Z",
                    "compromised": False,
                    "cross-validation": {},
                    "canary-validation": {}
                }
            ]
        }

    We're interested in the individual sensors.

    :param results: Parsed results from */validate/check REST JSON response
    :return: List of errors, empty list for no errors
    """
    # validate the sensor list
    errors = []
    if "sensors" in results:
        for sensor in results["sensors"]:
            errs = validate_sensor_validation(sensor)
            errors += errs
    else:
        errors.append("[sensors] key missing")

    # validate the top level object
    check_for = {
        "timestamp": is_timestamp,
        "error": is_boolean,
        "targeting": is_targeting
    }

    errors += run_validation(results, check_for)

    return errors


def validate_sensor_validation(sensor):
    """
    Validate a sensor data blob as received from a _validate/check_ call
    into the Sensing API. An individual sensor will look something like:

        {
            "virtue": uuid,
            "sensor": uuid,
            "name": "",
            "last-validated": "2017-10-31 20:40:28.190581Z",
            "compromised": False,
            "cross-validation": {},
            "canary-validation": {}
        }

    :param sensor: Individual sensor blob as parsed from */validate/check REST JSON response
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "virtue": is_uuid,
        "sensor": is_uuid,
        "name": has_value,
        "last-validated": is_timestamp,
        "last-validation-token": is_uuid,
        "compromised": is_boolean,
        "cross-validation": is_dict,
        "canary-validation": is_dict
    }

    return run_validation(sensor, check_for)


def validate_sensor_deregistration(sensor):
    """
    Validate a sensor deregistration data blob. It should look like:

        {
            "error": False,
            "timestamp": timestamp,
            "sensor": uuid,
            "deregistered": True
        }

    :param sensor: Sensor deregistration data blob
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "error": is_exactly(False),
        "deregistered": is_exactly(True)
    }

    return run_validation(sensor, check_for)


def validate_sensor_registration(sensor):
    """
    Validate a sensor data blob received via the sensor registration
    API call. The registration data return will look something like:

        {
            "sensor": uuid,
            "timestamp": timestamp,
            "error": false,
            "registered": true
        }

    :param sensor: Sensor registration data blob
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "error": is_exactly(False),
        "registered": is_exactly(True)
    }
    return run_validation(sensor, check_for)


def run_validation(object, validation):
    """
    Run a 'check_for' validation on an object, which will make sure that
    keys exist in an object, and the values of those keys are the proper
    values.

    A 'check_for' dictionary looks like:

        {
            "key": <is_* function> | <lambda returning boolean>,
            ...
        }

    :param object: A dictionary object
    :param validation: A 'check_for' dictionary
    :return: List of errors, empty list for no errors
    """
    errors = []

    for k, v in validation.items():

        if k in object:
            if v(object[k]):
                # we're good!
                pass
            else:
                errors.append("Value for key [%s] failed validation function [%s]" % (k, v.__name__))
        else:
            errors.append("Missing key [%s]" % (k,))
    return errors


def each_item(v_func):
    """
    Build a function that evaluates a list against a validation
    function. Given a list of booleans to evaluate, this should
    be called like:

        each_item(is_boolean)

    :param v_func: function for validation of items in list
    :return: Validation function to verify a list
    """

    def each_item_inner(l):
        for i in l:
            if not v_func(i):
                return False
        return True

    return each_item_inner


def is_fingerprint(v):
    """
    Make sure the given value is a 32 block hex fingerprint.

    :param v: candidate value
    :return: boolean
    """

    return re.match(r'^([0-9a-fA-F]{2}\:){31}([0-9a-fA-F]{2})$', v) is not None


def is_string(s):
    """
    Make sure the value is a string type.

    :param s: value to test
    :return:  boolean
    """
    return type(s) == type("hello")


def is_in(*kargs, **kwargs):
    """
    Make sure a value is in a given list of values (contained
    in the kargs. This should be called like:

        is_in(1, 2, 3)

    And will return a validation function.

    :param kargs: values in the set
    :return: validation function to verify a value in a set
    """

    def is_in_inner(val):
        return val in kargs

    return is_in_inner


def is_targeting(d):
    """
    Make sure the data in the provided dictionary is targeting
    key value pairs, and doesn't have extraneous data.

    Acceptable targeting keys:

        - cidr
        - virtue
        - username
        - address
        - application
        - resource
        - sensor

    :param d: candidate targeting dictionary
    :return: boolean
    """
    acceptable = set("cidr virtue username address application resource sensor".split(" "))

    for k in d.keys():
        if k not in acceptable:
            return False
    return True


def is_timestamp(str):
    """
    Make sure the string contains a timestamp that conforms
    to our expected time format of:

        2017-10-31 20:40:28.190581Z

    :param str: Possible time stamp
    :return: boolean
    """

    if str is None:
        return False
    try:
        datetime.datetime.strptime(str, "%Y-%m-%d %H:%M:%S.%fZ")
        return True
    except ValueError as ve:
        return False


def is_boolean(v):
    """
    Make sure the value V is a boolean.

    :param v: candidate value
    :return: boolean
    """
    return type(v) == type(False)


def is_dict(d):
    """
    Make sure the given value is a dictionary object.

    :param d:
    :return:
    """
    return type(d) == type({})


def is_exactly(v):
    """
    Create an exact comparator function.

    :param v: Value to compare against
    :return: boolean
    """

    def is_exactly_inner(c):
        return c == v

    return is_exactly_inner


def has_value(str):
    """
    Basically a nop, make sure the str isn't None
    :param str:
    :return:
    """
    return str != None


def is_uuid(str):
    """
    Is the given string a valid UUID?

    :param str: String or None
    :return: boolean
    """
    if str is None:
        return False
    else:
        return re.match(r'^[a-zA-Z0-9]{8}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{12}$', str) is not None


def generate_async_hanlder(payload, capture_dict):
    """
    Put a wrapper around a JSON payload for an aiohttp async
    handler.

    :param payload: JSON payload structure.
    :return:
    """
    async def inner_handler(request):

        # capture incoming data
        capture_dict["path"] = request.path
        capture_dict["request_body"] = {}
        print("got request on path [%s]" % (request.path,))
        # if request.can_read_body:
        #     capture_dict["request_body"] = await request.json()

        # serve up our preconfigured payload
        res = web.Response(text=json.dumps(payload), content_type="application/json")
        return res
    return inner_handler


async def close_async_http(app):
    """
    Handle proper teardown and cleanup of the async
    service.

    :param app:
    :param server:
    :return:
    """
    await app.shutdown()
    await app.cleanup()


def find_open_port(base):
    for port in range(base, 65000):
        with closing(socket.socket(socket.AF_INET, socket.SOCK_STREAM)) as sock:
            res = sock.connect_ex((socket.getfqdn(), port))
            if res != 0:
                return port


async def test_case(opts, test):
    """
    Run an individual test one or more times. A list of status dictionaries
    is returned with an entry for each iteration of the test. The dictionary
    looks like:

        {
            "pass": <True | False>,
            "parameters": {
                ":variable": "selected value"
            },
            "returns": {
                "expected": "JSON",
                "got": "cannot parse...."
            },
            "code": {
                "expected": 501,
                "got": 200
            },
            "result_has_fields": {
                "field name": "representative type for result"
            },

            # payload generator for the request body
            "request_body": {
                "key to insert into request body": "value for key"
            },

            # how do we validate what we get back from the API
            "results_validators": {
                "key": <validation function>
            },

            # run an http service async during the test case, with
            # optional validation of the incoming results
            "async_http": {
                "/sensor/{sensor}/registered": {
                    "serve": {
                        "error": False,
                        "msg": "ack"
                    },
                    "method": "GET",
                    "incoming_validators": []
                }
            }

        }

    :param opts: Command configuration options
    :param test: Test case as defined in the *test_api* method
    :param repeat: Number of variations of the test to run, if interpolated parameters exist
    :return: Test results list
    """
    results = []

    # force repeat to one if we don't have variable params
    if not test_uri_has_parameters(test["path"]):
        repeat = 1

    # let's rock this joint
    for rep in range(opts.test_repeat):

        # start building our result object
        rep_result = {
            "returns": {
                "expected": test["returns"],
                "got": ""
            },
            "code": {
                "expected": test["code"],
                "got": 0
            },
            "pass": False,
            "parameters": {},
            "async_http": {}
        }

        # build a URI
        uri_path, selected_params = test_interpolate_uri_parameters(test["path"])
        full_uri = construct_api_uri(opts, uri_path)

        # record the randomized parameters
        rep_result["parameters"] = selected_params
        threw_exception = False
        exception_payload = {}

        response_text = ""

        try:

            # it's possible we need an asynchronous HTTP server running to handle
            # side channel results/responses/requests from the HTTP server to
            # the "sensor" we're pretending to be. Here we setup any routes
            # that are predefined. The async_http definition looks like:
            #
            #        "async_http": {
            #            "/sensor/{sensor}/registered": {
            #                "serve": {
            #                    "error": False,
            #                    "msg": "ack"
            #                },
            #                "method": "GET",
            #                "incoming_validators": []
            #            }
            #        }
            async_incoming_payloads = {}
            async_server_port = 0
            if "async_http" in test:

                loop = asyncio.get_event_loop()

                # setup the app
                async_web_app = web.Application(loop=loop)

                # define any routes
                route_handlers = {}
                for route, config in test["async_http"].items():

                    # capture payloads
                    async_incoming_payloads[route] = {"path": "", "request_body": {}}

                    # build the handler
                    route_handlers[route] = generate_async_hanlder(config["serve"], async_incoming_payloads[route])

                    # register the handler
                    if config["method"] == "GET":
                        async_web_app.router.add_get(route, route_handlers[route])
                    elif config["method"] == "PUT":
                        async_web_app.router.add_put(route, route_handlers[route])
                    elif config["method"] == "POST":
                        async_web_app.router.add_post(route, route_handlers[route])

                # pick a port
                async_server_port = find_open_port(opts.test_port)
                async_server_host = socket.getfqdn()
                print("  = using [%s:%d] for async http server" % (async_server_host, async_server_port,))
                # run the app

                # create the server and wait for it to fully spin up
                await loop.create_server(async_web_app.make_handler(), async_server_host, async_server_port)


            # construct request
            #  but first, are we authenticating?
            if "authenticate" in test and test["authenticate"]:
                if test["method"].lower() == "get":

                    # determine any parameters for our get request
                    get_params = test_interpolate_parameters(test)

                    # rather than the standard requests library, we're going to be handling
                    # our http requests through the aiohttp lib, so we can run them as non-
                    # blocking operations
                    async with ClientSession() as session:
                        async with session.get(full_uri, params=get_params) as response:
                            res = response

                            # let's read in our response, which may be chunked
                            chunked_binary = b''
                            try:
                                while True:
                                    chunk = await res.content.read(64 * 1024)
                                    if not chunk and res.content.at_eof():
                                        break
                                    chunked_binary += chunk
                            except ClientConnectionError as cce:
                                # print("caught aiohttp ClientConnectionError")
                                #
                                # We're eating this error because in certain circumstances
                                # the aiohttp library decides to throw an exception when
                                # the remote stream (in streaming situations) closes, rather
                                # than just EOF the stream reader. Because WFT.
                                pass

                            # decode to UTF from the binary string we received
                            response_text = chunked_binary.decode("utf-8")


                else:

                    # generate the request body payload
                    request_body = {"userToken": test_generate_user_token()}
                    if "request_body" in test:
                        request_body.update(test_interpolate_request_body(test["request_body"]))

                    # if we're using an async server, and we have a request body value of "async_port",
                    # we need to fix that to be the port we've selected for this test
                    for k, v in request_body.items():
                        if v == "async_port":
                            request_body[k] = async_server_port

                    # rather than the standard requests library, we're going to be handling
                    # our http requests through the aiohttp lib, so we can run them as non-
                    # blocking operations
                    async with ClientSession() as session:
                        async with session.put(full_uri, data=request_body) as response:
                            res = response
                            # let's read in our response, which may be chunked
                            chunked_binary = b''
                            try:
                                while True:
                                    chunk = await res.content.read(64 * 1024)
                                    if not chunk and res.content.at_eof():
                                        break
                                    chunked_binary += chunk
                            except ClientConnectionError as cce:
                                # print("caught aiohttp ClientConnectionError")
                                #
                                # We're eating this error because in certain circumstances
                                # the aiohttp library decides to throw an exception when
                                # the remote stream (in streaming situations) closes, rather
                                # than just EOF the stream reader. Because WFT.
                                pass

                            # decode to UTF from the binary string we received
                            response_text += chunked_binary.decode("utf-8")


            else:
                if test["method"].lower() == "get":

                    # determine any parameters for our get request
                    get_params = test_interpolate_parameters(test)

                    # rather than the standard requests library, we're going to be handling
                    # our http requests through the aiohttp lib, so we can run them as non-
                    # blocking operations
                    async with ClientSession() as session:
                        async with session.get(full_uri, params=get_params) as response:
                            res = response

                            # let's read in our response, which may be chunked
                            chunked_binary = b''
                            try:
                                while True:
                                    chunk = await res.content.read(64 * 1024)
                                    if not chunk and res.content.at_eof():
                                        break
                                    chunked_binary += chunk
                            except ClientConnectionError as cce:
                                # print("caught aiohttp ClientConnectionError")
                                #
                                # We're eating this error because in certain circumstances
                                # the aiohttp library decides to throw an exception when
                                # the remote stream (in streaming situations) closes, rather
                                # than just EOF the stream reader. Because WFT.
                                pass

                            # decode to UTF from the binary string we received
                            response_text = chunked_binary.decode("utf-8")

                else:

                    # generate the request body payload
                    request_body = {}
                    if "request_body" in test:
                        request_body.update(test_interpolate_request_body(test["request_body"]))

                    # if we're using an async server, and we have a request body value of "async_port",
                    # we need to fix that to be the port we've selected for this test
                    for k, v in request_body.items():
                        if v == "async_port":
                            request_body[k] = async_server_port

                    # rather than the standard requests library, we're going to be handling
                    # our http requests through the aiohttp lib, so we can run them as non-
                    # blocking operations
                    async with ClientSession() as session:
                        async with session.put(full_uri, data=request_body) as response:
                            res = response
                            # let's read in our response, which may be chunked
                            chunked_binary = b''
                            try:
                                while True:
                                    chunk = await res.content.read(64 * 1024)
                                    if not chunk and res.content.at_eof():
                                        break
                                    chunked_binary += chunk
                            except ClientConnectionError as cce:
                                # print("caught aiohttp ClientConnectionError")
                                #
                                # We're eating this error because in certain circumstances
                                # the aiohttp library decides to throw an exception when
                                # the remote stream (in streaming situations) closes, rather
                                # than just EOF the stream reader. Because WFT.
                                pass

                            # decode to UTF from the binary string we received
                            response_text = chunked_binary.decode("utf-8")

            # spin down the async web server if it is running
            if "async_http" in test:

                # close it all down
                # async_server.close()
                await close_async_http(async_web_app)

                # save our async results
                rep_result["async_http"] = async_incoming_payloads


        except requests.exceptions.ConnectionError as rece:
            threw_exception = True
            exception_payload = {
                "code": "ConnectionError",
                "msg": str(rece)
            }

        # check results
        did_pass = True

        # let's make sure that if we threw an exception in the connection/request process, we
        # bail early
        if threw_exception:

            # ok, so we got an exception error, but did it pass
            # the test case?
            #
            # TODO: After the migration to Cowboy 2.x this can probably be removed,
            #       as it is only here to catch a special case of a remote connection
            #       drop related to fuzzing crashing (without exploit) the connection.
            if type(test["code"]) == type([]):
                # it's possible our code is a list, in which case we need to be in that list
                if exception_payload["code"] in test["code"]:
                    rep_result["pass"] = True
            else:
                if exception_payload["code"] == test["code"]:
                    rep_result["pass"] = True

            rep_result["code"]["got"] = exception_payload["code"]
            rep_result["result"] = exception_payload["msg"]
            results.append(rep_result)
            continue

        # make sure we got the status code we expected
        # rep_result["code"]["got"] = res.status_code
        rep_result["code"]["got"] = res.status

        if type(test["code"]) == type([]):
            # it's possible our code is a list, in which case we need to be in that list
            if res.status not in test["code"]:
                did_pass = False
        else:
            if res.status != test["code"]:
                did_pass = False

        # # let's read in our response, which may be chunked
        # chunked_binary = b''
        # try:
        #     while True:
        #         chunk = await res.content.read(64 * 1024)
        #         print(chunk)
        #         if not chunk and res.content.at_eof():
        #             print("chunk break")
        #             break
        #         chunked_binary += chunk
        # except ClientConnectionError as cce:
        #     # print("caught aiohttp ClientConnectionError")
        #     #
        #     # We're eating this error because in certain circumstances
        #     # the aiohttp library decides to throw an exception when
        #     # the remote stream (in streaming situations) closes, rather
        #     # than just EOF the stream reader. Because WFT.
        #     print("chunk ClientConnectionError")
        #     print(cce)
        #     pass
        #
        # # decode to UTF from the binary string we received
        # response_text = chunked_binary.decode("utf-8")

        # close out the response
        res.close()

        # make sure we got JSON or JSONL if that's what we expected, and then
        # verify the data from the results
        # rep_result["returns"]["got"] = await res.text()
        rep_result["returns"]["got"] = response_text
        if test["returns"].lower() == "json":
            try:

                # did we get JSON?
                # res_json = await res.json()
                res_json = json.loads(response_text)
                rep_result["returns"]["got"] = "JSON"
                rep_result["result"] = res_json

                # validate from our result_has_fields, which looks like:
                #
                #       {
                #           "key": value,
                #           "key": value,
                #           ...
                #       }
                #
                # Which we use to validate in multiple ways:
                #   - key must exist
                #   - type of key in results must match type in result_has_fields
                if "result_has_fields" in test:
                    rep_result["result_has_fields"] = []
                    for key in test["result_has_fields"].keys():

                        # key exists
                        if key not in res_json:
                            rep_result["result_has_fields"].append("The [%s] key is missing from the results" % (key,))
                            did_pass = False

                        # types match
                        if key in res_json:
                            if type(test["result_has_fields"][key]) != type(res_json[key]):
                                rep_result["result_has_fields"].append(
                                    "The field [%s] in the results has the wrong type. Expected (%s) got (%s)" %
                                    (
                                        key,
                                        type(test["result_has_fields"][key]),
                                        type(res_json[key])
                                    )
                                )

                # Run any results_validators we have, which do deep value inspection
                if "results_validators" in test:
                    rep_result["results_validators"] = {}

                    # run the individual validators
                    for res_validator in test["results_validators"]:

                        # grab errors and keep them
                        errors = res_validator(res_json)
                        rep_result["results_validators"][res_validator.__name__] = errors

                        # anything other than 0 errors is a fail case
                        if len(errors) > 0:
                            did_pass = False

            except ValueError as ve:

                # This is another work around for fuzzing cases where Elixir (Cowboy, in particular)
                # throws HTTP/400 back with no content after particularly badly malformed requests.
                if type(rep_result["code"]["expected"]) == type([]) and 400 in rep_result["code"]["expected"] and response_text.strip() == "":
                    pass
                else:
                    print(ve)
                    print(response_text)
                    rep_result["returns"]["got"] = str(ve)
                    # rep_result["returns"]["raw"] = res.text
                    rep_result["returns"]["raw"] = response_text
                    did_pass = False
        elif test["returns"].lower() == "jsonl":

            # we're going to start by splitting our response on newlines
            # responses = await res.text()
            responses = response_text
            responses = responses.split("\n")

            for res_line in responses:

                # skip over the blank lines
                if res_line.strip() == "":
                    continue

                try:

                    # did we get JSON?
                    res_json = json.loads(res_line)

                    rep_result["returns"]["got"] = "JSON"
                    rep_result["result"] = res_json

                    # validate from our result_has_fields, which looks like:
                    #
                    #       {
                    #           "key": value,
                    #           "key": value,
                    #           ...
                    #       }
                    #
                    # Which we use to validate in multiple ways:
                    #   - key must exist
                    #   - type of key in results must match type in result_has_fields
                    if "result_has_fields" in test:
                        rep_result["result_has_fields"] = []
                        for key in test["result_has_fields"].keys():

                            # key exists
                            if key not in res_json:
                                rep_result["result_has_fields"].append(
                                    "The [%s] key is missing from the results" % (key,))
                                did_pass = False

                            # types match
                            if key in res_json:
                                if type(test["result_has_fields"][key]) != type(res_json[key]):
                                    rep_result["result_has_fields"].append(
                                        "The field [%s] in the results has the wrong type. Expected (%s) got (%s)" %
                                        (
                                            key,
                                            type(test["result_has_fields"][key]),
                                            type(res_json[key])
                                        )
                                    )

                    # Run any results_validators we have, which do deep value inspection
                    if "results_validators" in test:
                        rep_result["results_validators"] = {}

                        # run the individual validators
                        for res_validator in test["results_validators"]:

                            # grab errors and keep them
                            errors = res_validator(res_json)
                            rep_result["results_validators"][res_validator.__name__] = errors

                            # anything other than 0 errors is a fail case
                            if len(errors) > 0:
                                did_pass = False

                except Exception as e:
                    print(e)
                    rep_result["returns"]["got"] = str(e)
                    # rep_result["returns"]["raw"] = await res.text()
                    rep_result["returns"]["raw"] = response_text
                    did_pass = False

        rep_result["pass"] = did_pass

        # build test case evaluation
        results.append(rep_result)

    return results


def construct_api_uri(opts, uri_path, secure=True):
    """
    Build a full URI for a request to the API.

    :param opts: Command configuration options
    :param uri_path: Full path for the API
    :return: String URI
    """

    # setup the host
    host = opts.api_host

    if not host.startswith("http"):

        if secure:
            host = "https://%s:%d" % (host, opts.api_port_https)
        else:
            host = "http://%s:%d" % (host, opts.api_port_http)

    # setup the full uri
    return "%s/api/%s%s" % (host, opts.api_version, uri_path)


def test_generate_unauthenticated_tests(tests):
    """
    Given the existing body of tests, generate a set
    of unauthenticated tests for any existing tests that
    require authentication. Rewrite the conditions for this
    test to expect HTTP 401, and a results_validator of validate_is_error.

    :param tests: Existing body of tests
    :return: List of test cases
    """

    new_tests = []

    for test in tests:

        # generate unauthenticated test cases
        if test["authenticate"] == True:

            new_test = {}

            # copy the current test
            for k,v in test.items():
                new_test[k] = v

            # no longer authenticate
            new_test["authenticate"] = False

            # HTTP 401
            new_test["code"] = 401

            # result validators
            new_test["results_validators"] = [validate_is_error]

            # remove any "result_has_fields" tests
            new_test["result_has_fields"] = {}

            new_tests.append(new_test)

    return new_tests


def test_generate_fuzzing_tests(tests):
    """
    Given the existing body of tests, generate fuzzing tests for
    any test that would normally return a 200 or 401 status code.

    We create the fuzzing tests by:

        - rewriting the request path and parameters to use :*_fuzz keywords
        - rewrite the results_validators to be `validate_is_error`
        - rewrite the status code to be 400/invalid parameter for tests that
            returned 200, and leave status 401 for tests that were 401 status
        - remove any `result_has_fields` keys
        - rewrite any functions of the form test_parameter_* in the request_body

    :param tests: Existing test sets
    :return: List of fuzzing test cases
    """
    new_tests = []

    for test in tests:

        # HTTP/200 or HTTP/400
        if test["code"] in [200, 401]:

            new_test = {}

            # copy the current test
            for k, v in test.items():
                new_test[k] = v

            # status code rewrite. Ok. So status codes. Of a whole universe of
            # possible codes we might see, the follow are "ok" responses to fuzzing:
            #
            #       200 - Fuzzed value was parseable in context
            #       400 - Fuzzed value was an Invalid parameter
            #       404 - Fuzzed value altered path to a non-existent route
            #       414 - URI too long (we have some long values)
            #       ConnectionError - server is crashing the connection, and we get nothing back
            #
            # What we DON'T want to see is 500s, that means something has gone wrong
            # in the server, and we aren't properly protecting against it.
            #
            # TODO: After upgrade to Cowboy 2.x remove the Connection Error case, which
            #       is caused by an underlying bug in the :cow_lib.(unhex | urldecode)
            #       library used by Phoenix.
            #
            if new_test["code"] == 200:

                # invalid parameter or page not found (some of our fuzzing is path manipulation)
                new_test["code"] = [200, 400, 404, 414, 417, "ConnectionError"]

            if new_test["code"] == 401:

                # unauthorized OR not found
                new_test["code"] = [400, 401, 404, 414, "ConnectionError"]

            # parameter rewriting
            new_test["path"] = rewrite_fuzzing_path(new_test["path"])

            # rewrite any parameters
            if "parameters" in new_test:
                new_test["parameters"] = [p + "_fuzz" for p in new_test["parameters"]]

            # reset result_has_fields
            new_test["result_has_fields"] = {}

            # set the validator - this is basically an OR of two sets of validators
            new_test["results_validators"] = [validate_is_one_of([validate_is_error], new_test["results_validators"])]

            # check the request_body
            if "request_body" in test:
                new_request_body = {}

                for k, v in test["request_body"].items():
                    if not callable(v):
                        # just copy over anything that isn't a callable function/method
                        new_request_body[k] = v
                    else:

                        # is this method of the right naming convention?
                        if v.__name__.startswith("test_parameter_"):
                            fuzz_name = "%s_fuzz" % (v.__name__,)

                            # do we have a fuzzing method?
                            if fuzz_name in dict(globals(), **locals()):
                                new_request_body[k] = dict(globals(), **locals())[fuzz_name]
                            else:
                                # doh. we don't have a fuzzing function
                                raise NameError("No fuzzing function named [%s] exists" % (fuzz_name,))
                        else:
                            # don't need to rewrite
                            new_request_body[k] = v
                new_test["request_body"] = new_request_body


            new_tests.append(new_test)

    return new_tests


def rewrite_fuzzing_path(path):
    """
    Take apart a path like "/user/:username/something/:action" and relabel
    all of the keywords with *_fuzz, such that the resulting path is:

        /user/:username_fuzz/something/:action_fuzz


    :param path: Normal request path
    :return: Fuzzing request path
    """
    bits = path.split("/")[1:]
    new_bits = []

    for bit in bits:
        if bit.startswith(":"):
            new_bits.append("%s_fuzz" % (bit,))
        else:
            new_bits.append(bit)

    return "/%s" % ("/".join(new_bits),)


async def test_api(opts):
    """
    Test the virtue-security backend API.

    Each test is defined as a dictionary that looks like:

        {
            "path": "/path/to/command/:variable/",
            "method": "PUT",
            "returns": "JSON",
            "code": 501
        }

    Where:

        - *path* can define one or more variable parameters that will
          be interpreted at run time and filled in over the series
          of tests.
        - *method* is one of GET, PUT, POST, or DELETE
        - *expect* is one of JSON, NONE
        - *code* is a valid HTTP status code

    :param opts: Command configuration options
    :return:
    """

    tests = [

        # NETWORK API

        # === Observe
        {
            "method": "PUT",
            "path": "/network/:cidr/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/network/:cidr/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/network/:cidr/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        # todo: JSONL returns

        {
            "method": "GET",
            "path": "/network/:cidr/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/network/:cidr/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/network/:cidr/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/network/:cidr/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases
        {
            "method": "GET",
            "path": "/network/not_a_cidr/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "results_validators": [validate_is_error]
        },
        {
            "method": "PUT",
            "path": "/network/not_a_cidr/validate/:validate_action",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "results_validators": [validate_is_error]
        },

        # VIRTUE API

        # === Observe
        {
            "method": "PUT",
            "path": "/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # VIRTUAL MACHINE API

        # === Observe
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases
        {
            "method": "GET",
            "path": "/vm/address/300.300.300.300/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },
        {
            "method": "GET",
            "path": "/vm/address/not{real{hostname/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        # APPLICATION API
        #   Note for application targeting, we use a combinator of filters, which can be used
        #   singularly, or in ordered combinations to allow fine grained target selection.
        #   See the Sensing API documentation for more details. This is why we see more variations
        #   of possible call paths for Application vs any other selectors.


        # === Observe
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },


        # === Stream
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },

        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # RESOURCE API
        #   Like the Application API, some of the interactions with the Resource API use a combinator
        #   approach for targeting. See the Sensing API document for more information.

        # === Observe
        {
            "method": "PUT",
            "path": "/resource/:resource/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/resource/:resource/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/resource/:resource/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },


        # === Stream
        {
            "method": "GET",
            "path": "/resource/:resource/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # == Inspect
        {
            "method": "GET",
            "path": "/resource/:resource/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/resource/:resource/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },

        {
            "method": "PUT",
            "path": "/resource/:resource/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases

        #       invalid resource id
        {
            "method": "GET",
            "path": "/resource/123123123123/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue id
        {
            "method": "GET",
            "path": "/resource/virtue/123456789/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application id
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/123456789/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue ID
        {
            "method": "GET",
            "path": "/resource/virtue/12334346456/user/:username/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue ID
        {
            "method": "GET",
            "path": "/resource/virtue/123456789/application/:application/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application ID
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/123456789/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application ID
        {
            "method": "GET",
            "path": "/resource/user/:username/application/123456798/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        # USER API

        # === Observe
        {
            "method": "PUT",
            "path": "/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # SENSOR API

        # === Configure
        {
            "method": "GET",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "configuration": {}
            },
            "results_validators": [validate_configure_review]
        },

        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "request_body": {
                "configuration": "http://resource.twosixlabs.com/path/to/something"
            },
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "config_source": "",
                "msg": ""
            },
            "results_validators": [validate_configure_update]
        },

        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "request_body": {
                "configuration": "dHdvc2l4bGFicw=="
            },
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "config_source": "",
                "msg": ""
            },
            "results_validators": [validate_configure_update]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/sensor/:sensor/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        {
            "method": "GET",
            "path": "/sensor/:sensor/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": [],
            "results_validators": [validate_stream_message]
        },

        # --- Failure Cases

        #     Invalid Sensor ID
        {
            "method": "GET",
            "path": "/sensor/1324567654323456/configure",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Unauthenticated
        {
            "method": "GET",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 401,
            "authenticate": False,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Missing configuration payload
        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Unauthenticated
        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 401,
            "authenticate": False,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/sensor/:sensor/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/sensor/:sensor/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # === Register
        {
            "method": "PUT",
            "path": "/sensor/:sensor/register",
            "returns": "JSON",
            "code": 200,
            "authenticate": False,
            "results_validators": [validate_sensor_registration],
            "request_body": {
                "sensor": test_parameter_sensor,
                "virtue": test_parameter_virtue,
                "user": test_parameter_username,
                "public_key": base64.urlsafe_b64encode(load_public_key("cert/rsa_key.pub").encode()).decode('iso-8859-1'),
                "hostname": socket.getfqdn(),
                "port": "async_port"
            },
            "async_http": {
                "/sensor/{sensor}/registered": {
                    "serve": {
                        "error": False,
                        "msg": "ack"
                    },
                    "method": "GET",
                    "incoming_validators": []
                }
            }
        },

        # === Deregister
        # TODO: add a test for the HTTP 200 case when we add support for
        #       :before steps in test cases (see: https://github.com/twosixlabs/savior/issues/8)
        {
            "method": "PUT",
            "path": "/sensor/:sensor/deregister",
            "returns": "JSON",
            "code": 400,
            "authenticate": False,
            "results_validators": [validate_is_error], #[validate_sensor_deregistration],
            "request_body": {
                "sensor": test_parameter_sensor,
                "public_key": base64.urlsafe_b64encode(load_public_key("cert/rsa_key.pub").encode()).decode("iso-8859-1")
            }
        },

        # ENUM API
        {
            "method": "GET",
            "path": "/enum/observation/levels",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_isnt_error]
        },
        {
            "method": "GET",
            "path": "/enum/log/levels",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_isnt_error]
        },

    ]

    # generate unauthenticated tests
    if opts.test_unauthenticated:
        tests += test_generate_unauthenticated_tests(tests)

    # fuzzing tests
    if opts.test_fuzzing:
        tests += test_generate_fuzzing_tests(tests)

    print("virtue-security/test - running API endpoint response tests")
    print("  :: %d tests available" % (len(tests),))

    # apply our test filter
    tests = [t for t in tests if t["path"].startswith(opts.test_path)]
    print("  :: %d tests matching --test-path filter" % (len(tests),))

    # apply the suffix filter
    if opts.skip_suffix is not None:

        # we can skip multiple suffixes separated by a semi-colon
        suffixes = [opts.skip_suffix]
        if "," in opts.skip_suffix:
            suffixes = opts.skip_suffix.split(",")

        for suffix in suffixes:
            tests = [t for t in tests if not t["path"].endswith(suffix)]
        print("  :: %d tests matching --skip-suffix filter" % (len(tests),))


    # track pass/fail totals
    total_pass = 0
    total_fail = 0
    fail_codes = {}
    fail_paths = set()

    # track how many of the tests included run_validators
    total_with_results_validators = 0

    # temporarily track NOT IMPLEMENTED code 501 returns
    total_not_implemented = 0

    # let's track the test time
    test_start = datetime.datetime.now()

    # now run the individual tests
    for test in tests:

        print("\t%(method)s %(path)s" % test)

        # run the test and record the results
        results = await test_case(opts, test)

        passes = len([t for t in results if t["pass"]])
        fails = len(results) - passes

        total_fail += fails
        total_pass += passes

        # with what status codes did we fail?
        for test_result in results:

            # track test failures by a few different means for reporting
            if not test_result["pass"]:

                # store the path we failed
                fail_paths.add("%(method)s %(path)s" % test)

                # store the failure codes for later use
                fail_code = test_result["code"]["got"]
                if fail_code not in fail_codes:
                    fail_codes[fail_code] = 0

                fail_codes[fail_code] += 1

            # track 501s
            if test_result["code"]["got"] == 501:
                total_not_implemented += 1

        # were there results_validators run for these tests?
        if "results_validators" in test:
            if len(test["results_validators"]) > 0:
                total_with_results_validators += 1

        # report on what passed/failed
        print("\t\t%d/%d passed" % (passes, len(results)))

        # if we had failures, we dump the results
        if fails > 0:
            print(json.dumps(results, indent=4))

    # time tracking
    test_end = datetime.datetime.now()
    test_elapsed = test_end - test_start

    # summary report
    print("  :: TEST SUMMARY")
    print(
"""
  :: %(passed)d passed, %(failed)d failed out of %(total)d total tests in %(elapsed_time)s
       %(percent_pass)0.2f%% pass rate
       %(percent_with_validators)0.2f%% validator coverage
       %(test_cases)d test cases
       %(test_cases_with_validators)d test cases with results validators
""" %
        {
            "passed": total_pass,
            "failed": total_fail,
            "total": total_pass + total_fail,
            "percent_pass": (total_pass * 1.0) / ( (total_pass + total_fail) * 1.0) * 100.0,
            "test_cases": len(tests),
            "test_cases_with_validators": total_with_results_validators,
            "percent_with_validators": (total_with_results_validators * 1.0) / (len(tests) * 1.0) * 100.0,
            "elapsed_time": str(test_elapsed)
        }
    )

    # report on NOT IMPLEMENTED returns
    if total_not_implemented > 0:
        print("\tHTTP(501) - not implemented results: %d" % (total_not_implemented,))

    # report on failure codes if we had any
    if len(fail_codes) > 0:
        print("    HTTP status_code for failures")
        for fail_code in sorted(fail_codes.keys()):
            print("      %s == %d" % (str(fail_code), fail_codes[fail_code]))

    # report on which unique paths failed
    if len(fail_paths) > 0:
        print("    Failed paths")
        for fail_path in list(fail_paths):
            print("      %s" % (fail_path,))


def load_public_key(key_path):
    """
    Load and validate a public key for use with the API.

    An exception is raised if the public key is invalid

    :param key_path: Path to the public key.
    :return: PEM String
    """

    key_string = open(key_path, 'r').read()

    # validate the key
    try:
        rsakey = RSA.importKey(key_string)
    except ValueError as ve:

        print("Couldn't import RSA public key at %s - %s" % (key_path, str(ve)))
        print("  If this is encountered during testing, run the gen_cert.sh script to create a key pair, and try testing again")
    return key_string


async def api_version(opts):
    """
    Report on the version of the CLI utility and the running
    Sensing API if we can reach it.

    :param opts:
    :return:
    """
    print("virtue-security(version=%s)" % (__VERSION__,))

    # we need to custom code the conversion of the API endpoint to a full
    # URI because the version function sits outside of the semantic versioned
    # endpoint heirarchy

    # setup the host
    host = opts.api_host

    if not host.startswith("http"):
        host = "http://%s" % (host,)

    # setup the full uri
    uri = "%s:%d/version" % (host, opts.api_port_http)

    try:
        res = requests.get(uri)
        api_json = res.json()
        print("sensing-api(version=%s)" % (api_json["version"],))
    except requests.exceptions.Timeout as ret:
        print("-- timeout error connected to Sensing API (%s)" % (uri,))
    except ValueError as ve:
        print(ve)


def extract_jsonl_line(binary):
    """
    Scan through the binary looking for the first newline - if we find
    one we want to split apart the binary and return the extracted line
    decoded into a UTF-8 string, and the remaining binary.

    :param binary: binary stream
    :return: (utf8_string, binary_remainder)
    """
    break_idx = -1

    for idx, c in enumerate(binary):
        if c == 10:
            break_idx = idx
            break

    if break_idx >= 0:
        s = binary[0:break_idx].decode("utf-8")

        # shift past the newline if we can
        if len(binary) > (break_idx + 1):
            break_idx += 1
        return s, binary[break_idx:]

    else:
        return None, binary


def http_code_to_message(code):
    """
    Convert an HTTP response status code into a useful message.

    This is a wrapper around the standard HTTP codes as well as the extended
    4xx CloudFlare TLS/SSL codes used by the Sensing API

    :param code:
    :return:
    """
    custom_codes = {
        495: "TLS/SSL Certificate Validation Error",
        496: "TLS/SSL Certificate Required"
    }

    if code in http.client.responses:
        return http.client.responses[code]
    elif code in custom_codes:
        return custom_codes[code]
    else:
        return ""


async def api_inspect(opts):
    """
    Query the inspection endpoint.

    :param opts:
    :return:
    """

    if opts.var_virtue is not None and opts.var_username is not None:
        full_uri = construct_api_uri(opts, "/resource/virtue/%s/user/%s/inspect" % (opts.var_virtue, opts.var_username))

    elif opts.var_virtue is not None:
        full_uri = construct_api_uri(opts, "/virtue/%s/inspect" % (opts.var_virtue,))

    elif opts.var_username is not None:
        full_uri = construct_api_uri(opts, "/user/%s/inspect" % (opts.var_username,))

    elif opts.var_address is not None:
        full_uri = construct_api_uri(opts, "/vm/address/%s/inspect" % (opts.var_address,))

    elif opts.var_sensor is not None:
        full_uri = construct_api_uri(opts, "/sensor/%s/inspect" % (opts.var_sensor,))

    # connect with our Savior CA certificate and our instance specific client certificate
    client_cert_paths = (os.path.abspath(opts.public_key_path), os.path.abspath(opts.private_key_path))
    res = requests.get(full_uri, verify=opts.ca_key_path, cert=client_cert_paths)

    if res.status_code == 200:
        print(json.dumps(res.json(), indent=4))


async def api_observe(opts):
    """
    Set the observation level of a sensor or group of sensors, based on targeting.

    :param opts:
    :return:
    """

    if opts.var_virtue is not None and opts.var_username is not None:
        full_uri = construct_api_uri(opts, "/resource/virtue/%s/user/%s/observe/%s" % (opts.var_virtue, opts.var_username, opts.observation_level))

    elif opts.var_virtue is not None:
        full_uri = construct_api_uri(opts, "/virtue/%s/observe/%s" % (opts.var_virtue, opts.observation_level))

    elif opts.var_username is not None:
        full_uri = construct_api_uri(opts, "/user/%s/observe/%s" % (opts.var_username, opts.observation_level))

    elif opts.var_address is not None:
        full_uri = construct_api_uri(opts, "/vm/address/%s/observe/%s" % (opts.var_address, opts.observation_level))

    # send a PUT observe request to the API
    client_cert_paths = (os.path.abspath(opts.public_key_path), os.path.abspath(opts.private_key_path))
    res = requests.put(full_uri, verify=opts.ca_key_path, cert=client_cert_paths)


    if res.status_code == 200:
        print(json.dumps(res.json(), indent=4))
    else:
        print("Error: status_code(%d)" % (res.status_code,))
        print(json.dumps(res.json(), indent=4))


async def api_monitor(opts):
    """
    Monitor the Sensing API C2 kafka channel.

    :param opts:
    :return:
    """

    full_uri = construct_api_uri(opts, "/control/c2/channel")

    # setup our certificate paths
    client_cert_paths = (os.path.abspath(opts.public_key_path), os.path.abspath(opts.private_key_path))
    res = requests.get(full_uri, verify=opts.ca_key_path, cert=client_cert_paths)

    if res.status_code == 200:
        conf = res.json()
        channel = conf["channel"]
        bootstraps = conf["kafka_bootstrap_hosts"]
        print("%% monitoring Sensing API C2 on Kafka")
        print("    topic=%s" % (channel,))
        print("    bootstraps=[%s]" % (",".join(bootstraps)),)

        # see http://kafka-python.readthedocs.io/en/master/apidoc/KafkaProducer.html for more on using client certificates
        for msg in kafka.KafkaConsumer(
                channel,
                bootstrap_servers=bootstraps,
                value_deserializer=json.loads,
                ssl_cafile=opts.ca_key_path,
                ssl_certfile=opts.public_key_path,
                ssl_keyfile=opts.private_key_path,
                security_protocol="SSL"):

            # what do we do with this information
            if msg.value["action"] == "heartbeat":
                print("ðŸ’“ - (timestamp=%s)" % (msg.value["timestamp"]))
            elif msg.value["action"] == "sensor-registration":
                print("+ REGISTRATION - (timestamp=%s, sensor_id=%s, topic=%s, name=%s)" % (
                    msg.value["timestamp"],
                    msg.value["sensor"]["sensor"],
                    msg.value["topic"],
                    msg.value["sensor"]["sensor_name"]
                ))
            elif msg.value["action"] == "sensor-deregistration":
                print("- DEREGISTRATION - (timestamp=%s, sensor_id=%s, topic=%s, name=%s)" % (
                    msg.value["timestamp"],
                    msg.value["sensor"]["sensor"],
                    msg.value["topic"],
                    msg.value["sensor"]["sensor_name"]
                ))
            else:
                print("!! (timestamp=%s, action=%s) unrecognized monitor action" % (
                    msg.value["timestamp"], msg.value["action"]
                ))
                print(json.dumps(msg.value, indent=4))
    else:
        print("%% error encountered trying to connect to Sensing API to retrieve monitor channel")
        print("   ! status_code(%d): %s" % (res.status_code, http_code_to_message(res.status_code)))


async def api_stream(opts):
    """
    Retrieve the JSONL stream from the server and print it out.

    :param opts:
    :return:
    """

    # build up our parameters
    since = since_datetime(opts.time_since)
    follow = opts.log_follow
    log_level = opts.log_level

    full_uri = construct_api_uri(opts, "/sensor/%s/stream" % (opts.var_sensor,))

    if opts.var_username is not None:
        full_uri = construct_api_uri(opts, "/user/%s/stream" % (opts.var_username,))

    elif opts.var_sensor is not None:
        full_uri = construct_api_uri(opts, "/sensor/%s/stream" % (opts.var_sensor,))

    get_params = {
        "follow": str(follow),
        "since": since.isoformat(),
        "filter_level": log_level
    }

    # spin up our request and start streaming
    ssl_context = ssl.create_default_context(ssl.Purpose.SERVER_AUTH)
    ssl_context.load_verify_locations(cafile=opts.ca_key_path)
    ssl_context.load_cert_chain(os.path.abspath(opts.public_key_path), os.path.abspath(opts.private_key_path))

    async with ClientSession(read_timeout=None) as session:
        async with session.get(full_uri, params=get_params, ssl_context=ssl_context) as response:

            # this is an async stream reader, so we pull in byte arrays
            chunked_binary = b''
            try:
                while True:
                    chunk = await response.content.read(1024)
                    if not chunk:
                        if len(chunked_binary) > 0:
                            manage_stream_output(opts, chunked_binary.decode("utf-8"))
                        break

                    chunked_binary += chunk

                    # try and parse out a full line up to a newline
                    msg, chunked_binary = extract_jsonl_line(chunked_binary)

                    # if we have a message, let's do something with it
                    if msg is not None:
                        manage_stream_output(opts, msg)

            except ClientConnectionError as cce:
                # print("caught aiohttp ClientConnectionError")
                #
                # We're eating this error because in certain circumstances
                # the aiohttp library decides to throw an exception when
                # the remote stream (in streaming situations) closes, rather
                # than just EOF the stream reader. Because WFT.
                print(cce)


def manage_stream_output(opts, stream_line):
    """
    Manage the various options we need to apply for output of streaming data.

    :param opts:
    :param stream_line:
    :return:
    """

    # are we grepping?
    if opts.grep is not None:
        if opts.grep not in stream_line:
            return

    # are we pretty printing?
    if opts.output_pretty_print:
        print(json.dumps(json.loads(stream_line), indent=4))
    else:
        print(stream_line.strip())


def since_datetime(since_string):
    """
    Turn a string specification used in the _since_ flag into a timedelta
    we can use to manipulate the stream history. The return value is a
    local TZ naive datetime.

    Since times can look like:

        -2 minutes
        15 minutes ago
        1 hour

    :param since_string: A human readable/specified relative time delta
    :return: relative adjusted datetime
    """

    # TODO: Fix me once we figure out why Kafka is internally tracking two hours ahead of everything
    corrective_td = datetime.timedelta(seconds = 60*60*2)

    if since_string is None:
        return datetime.datetime.now(tz=pytz.utc) + corrective_td

    if since_string.startswith("-"):
        since_string = since_string[1:].strip()

    if "ago" in since_string:
        since_string = since_string.replace("ago", "").strip()

    seconds = pytimeparse.parse(since_string)

    if seconds is None:
        raise ValueError("The relative time specified by --since is not a valid time offset. Try \"3 minutes ago\".")

    return datetime.datetime.now(tz=pytz.utc) - datetime.timedelta(seconds = seconds) + corrective_td


def options():
    """
    Parse out the command line options.

    :return:
    """
    parser = argparse.ArgumentParser(description="Interact with the SAVIOR VirtUE security API")

    # top level control
    parser.add_argument("mode", metavar="M", help="Top level interaction", choices=["test", "version", "stream", "monitor", "inspect", "observe"])
    #parser.add_argument("sub_mode", metavar="S", help="Next level interaction", choices=[""])

    # identification variables
    parser.add_argument("--network", dest="var_network", default=None, help="Network or IP in CIDR format")
    parser.add_argument("--virtue-id", dest="var_virtue", default=None, help="Virtue ID")
    parser.add_argument("--sensor-id", dest="var_sensor", default=None, help="Sensor ID")
    parser.add_argument("--username", dest="var_username", default=None, help="Virtue Username")
    parser.add_argument("--address", dest="var_address", default=None, help="Virtue Address")

    # sensor control states
    parser.add_argument("--level", dest="observation_level", default="off", help="Observation level")
    parser.add_argument("--action", dest="trust_action", default="invalidate", help="Validate or invalidate trust",
                        choices=["validate", "invalidate"])
    parser.add_argument("--filter-log-level", dest="log_level", default="everything",
                        help="Log level below which to filter out messages",
                        choices=["everything", "debug", "info", "warning", "error", "event"])

    parser.add_argument("--since", dest="time_since", default=None, help="Time or timestamp in log history")
    parser.add_argument("--follow", dest="log_follow", default=False, action="store_true", help="Follow the log stream")

    # key management
    parser.add_argument("--public-key-path", dest="public_key_path", default=None, help="Path to the public key to use")
    parser.add_argument("--private-key-path", dest="private_key_path", default=None, help="Path to the private key to use")
    parser.add_argument("--ca-key-path", dest="ca_key_path", default=None, help="Where to store the Certificate Authority Root Public Key")

    # communications
    parser.add_argument("-a", "--api-host", dest="api_host", default="api", help="API host URI")
    parser.add_argument("--api-port-https", dest="api_port_https", default=17504, type=int, help="API HTTPS port")
    parser.add_argument("--api-port-http", dest="api_port_http", default=17141, type=int, help="API HTTP port")

    parser.add_argument("--api-version", dest="api_version", default="v1", help="API version being called")

    # for API testing
    parser.add_argument("--test-path", dest="test_path", default="/", help="Filter prefix for selecting tests. Defaults to selecting all tests")
    parser.add_argument("--skip-suffix", dest="skip_suffix", default=None, help="Skip tests that end with the specified suffix. Separate multiple suffixes with ,")
    parser.add_argument("--skip-unauthenticated-tests", dest="test_unauthenticated", default=True, action="store_false", help="Skip the generation of un-authenticated tests")
    parser.add_argument("--skip-fuzzing-tests", dest="test_fuzzing", default=True, action="store_false", help="Skip the generation of fuzzing tests")
    parser.add_argument("--test-repeat", dest="test_repeat", default=5, type=int, help="How many iterations of each test should run")
    parser.add_argument("--test-sensor-http-port", dest="test_port", default=11111, type=int, help="Port to bind for local async http server used during testing")

    # stream formatting and control
    parser.add_argument("--grep", dest="grep", default=None, help="String to grep for in stream data")
    parser.add_argument("--pretty-print", dest="output_pretty_print", default=False, action="store_true", help="Pretty print JSON based outputs")

    return parser.parse_args()


if __name__ == "__main__":

    opts = options()

    # dispatch our command based upon the primary mode
    dispatch = {
        "test": test_api,
        "version": api_version,
        "stream": api_stream,
        "monitor": api_monitor,
        "inspect": api_inspect,
        "observe": api_observe
    }

    if opts.mode not in dispatch:
        print("There is no [%s] mode, please try again, or use the --help flag" % (opts.mode,))
        sys.exit(1)

    # let's get the root CA key
    loop = asyncio.get_event_loop()
    loop.run_until_complete(dispatch[opts.mode](opts))

