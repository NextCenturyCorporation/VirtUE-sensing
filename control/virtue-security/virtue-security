#!/usr/local/bin/python
__VERSION__ = "1"

import argparse
import datetime
import json
import random
import re
import requests
import sys
import uuid


def fuzzing_from_blns():
    """
    What a wonderful resource [The Big List of Naughty Strings](https://github.com/minimaxir/big-list-of-naughty-strings)
    is. This method will return a random string from a subset of this list that is useful
    for URI/query param fuzzing.

    I would really, seriously recommend you not edit this function. I would also collapse this function in
    your editor if at all possible, as most layout engines go a bit bonkers trying to update this
    section. Also, your syntax hinting for a few lines after this function may be unreliable.

    :return: String
    """
    warm_fuzzies_from_blns = [
	"undefined","undef","null","NULL","(null)","nil","NIL","true","false","True",
	"False","TRUE","FALSE","None","hasOwnProperty","0","1","1.00","$1.00","1/2",
	"1E2","1E02","1E+02","-1","-1.00","-$1.00","-1/2","-1E2","-1E02","-1E+02",
	"1/0","0/0","-2147483648/-1","-9223372036854775808/-1","-0","-0.0","+0",
	"+0.0","0.00","0..0",".","0.0.0","0,00","0,,0",",","0,0,0","0.0/0","1.0/0.0",
	"0.0/0.0","1,0/0,0","0,0/0,0","--1","-","-.","-,",
	"999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999",
	"NaN","Infinity","-Infinity","INF","1#INF","-1#IND","1#QNAN","1#SNAN",
	"1#IND","0x0","0xffffffff","0xffffffffffffffff","0xabad1dea",
	"123456789012345678901234567890123456789","1,000.00","1 000.00","1'000.00",
	"1,000,000.00","1 000 000.00","1'000'000.00","1.000,00","1 000,00","1'000,00",
	"1.000.000,00","1 000 000,00","1'000'000,00","01000","08","09",
	"2.2250738585072011e-308",",./;'[]\-=","<>?:{}|_+","!@#$%^&*()`~",
	"",
	"","	              ​    　",
	"­؀؁؂؃؄؅؜۝܏᠎​‌‍‎‏‪‫‬‭‮⁠⁡⁢⁣⁤⁦⁧⁨⁩⁪⁫⁬⁭⁮⁯﻿￹￺￻𑂽𛲠𛲡𛲢𛲣𝅳𝅴𝅵𝅶𝅷𝅸𝅹𝅺󠀁󠀠󠀡󠀢󠀣󠀤󠀥󠀦󠀧󠀨󠀩󠀪󠀫󠀬󠀭󠀮󠀯󠀰󠀱󠀲󠀳󠀴󠀵󠀶󠀷󠀸󠀹󠀺󠀻󠀼󠀽󠀾󠀿󠁀󠁁󠁂󠁃󠁄󠁅󠁆󠁇󠁈󠁉󠁊󠁋󠁌󠁍󠁎󠁏󠁐󠁑󠁒󠁓󠁔󠁕󠁖󠁗󠁘󠁙󠁚󠁛󠁜󠁝󠁞󠁟󠁠󠁡󠁢󠁣󠁤󠁥󠁦󠁧󠁨󠁩󠁪󠁫󠁬󠁭󠁮󠁯󠁰󠁱󠁲󠁳󠁴󠁵󠁶󠁷󠁸󠁹󠁺󠁻󠁼󠁽󠁾󠁿","Ω≈ç√∫˜µ≤≥÷",
	"åß∂ƒ©˙∆˚¬…æ","œ∑´®†¥¨ˆøπ“‘","¡™£¢∞§¶•ªº–≠","¸˛Ç◊ı˜Â¯˘¿","ÅÍÎÏ˝ÓÔÒÚÆ☃",
	"Œ„´‰ˇÁ¨ˆØ∏”’","`⁄€‹›ﬁﬂ‡°·‚—±","⅛⅜⅝⅞",
	"ЁЂЃЄЅІЇЈЉЊЋЌЍЎЏАБВГДЕЖЗИЙКЛМНОПРСТУФХЦЧШЩЪЫЬЭЮЯабвгдежзийклмнопрстуфхцчшщъыьэюя",
	"٠١٢٣٤٥٦٧٨٩","⁰⁴⁵","₀₁₂","⁰⁴⁵₀₁₂","ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็ ด้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็็้้้้้้้้็็็็็้้้้้็็็็","田中さんにあげて下さい",
	"パーティーへ行かないか","和製漢語","部落格","사회과학원 어학연구소",
	"찦차를 타고 온 펲시맨과 쑛다리 똠방각하","社會科學院語學研究所","울란바토르","𠜎𠜱𠝹𠱓𠱸𠲖𠳏",
	"Ⱥ","Ⱦ","ヽ༼ຈل͜ຈ༽ﾉ ヽ༼ຈل͜ຈ༽ﾉ","(｡◕ ∀ ◕｡)","｀ｨ(´∀｀∩","__ﾛ(,_,*)",
	"・(￣∀￣)・:*:","ﾟ･✿ヾ╲(｡◕‿◕｡)╱✿･ﾟ",",。・:*:・゜’( ☻ ω ☻ )。・:*:・゜’",
	"(╯°□°）╯︵ ┻━┻)","(ﾉಥ益ಥ）ﾉ﻿ ┻━┻","┬─┬ノ( º _ ºノ)","( ͡° ͜ʖ ͡°)",
	"😍","👩🏽","👾 🙇 💁 🙅 🙆 🙋 🙎 🙍","🐵 🙈 🙉 🙊",
	"❤️ 💔 💌 💕 💞 💓 💗 💖 💘 💝 💟 💜 💛 💚 💙","✋🏿 💪🏿 👐🏿 🙌🏿 👏🏿 🙏🏿",
	"🚾 🆒 🆓 🆕 🆖 🆗 🆙 🏧","0️⃣ 1️⃣ 2️⃣ 3️⃣ 4️⃣ 5️⃣ 6️⃣ 7️⃣ 8️⃣ 9️⃣ 🔟",
	"１２３","١٢٣",
"ثم نفس سقطت وبالتحديد،, جزيرتي باستخدام أن دنو. إذ هنا؟ الستار وتنصيب كان. أهّل ايطاليا، بريطانيا-فرنسا قد أخذ. سليمان، إتفاقية بين ما, يذكر الحدود أي بعد, معاملة بولندا،",
	"הָיְתָהtestالصفحات التّحول",
"﷽",
"ﷺ",
"مُنَاقَشَةُ سُبُلِ اِسْتِخْدَامِ اللُّغَةِ فِي النُّظُمِ الْقَائِمَةِ وَفِيم يَخُصَّ التَّطْبِيقَاتُ الْحاسُوبِيَّةُ، ",
	"‪‪test‪","‫test‫"," test ","test⁠test‫","⁦test⁧",
	"˙ɐnbᴉlɐ ɐuƃɐɯ ǝɹolop ʇǝ ǝɹoqɐl ʇn ʇunpᴉpᴉɔuᴉ ɹodɯǝʇ poɯsnᴉǝ op pǝs 'ʇᴉlǝ ƃuᴉɔsᴉdᴉpɐ ɹnʇǝʇɔǝsuoɔ 'ʇǝɯɐ ʇᴉs ɹolop ɯnsdᴉ ɯǝɹo˥",
	"00˙Ɩ$-","Ｔｈｅ ｑｕｉｃｋ ｂｒｏｗｎ ｆｏｘ ｊｕｍｐｓ ｏｖｅｒ ｔｈｅ ｌａｚｙ ｄｏｇ",
	"𝐓𝐡𝐞 𝐪𝐮𝐢𝐜𝐤 𝐛𝐫𝐨𝐰𝐧 𝐟𝐨𝐱 𝐣𝐮𝐦𝐩𝐬 𝐨𝐯𝐞𝐫 𝐭𝐡𝐞 𝐥𝐚𝐳𝐲 𝐝𝐨𝐠","𝕿𝖍𝖊 𝖖𝖚𝖎𝖈𝖐 𝖇𝖗𝖔𝖜𝖓 𝖋𝖔𝖝 𝖏𝖚𝖒𝖕𝖘 𝖔𝖛𝖊𝖗 𝖙𝖍𝖊 𝖑𝖆𝖟𝖞 𝖉𝖔𝖌",
	"𝑻𝒉𝒆 𝒒𝒖𝒊𝒄𝒌 𝒃𝒓𝒐𝒘𝒏 𝒇𝒐𝒙 𝒋𝒖𝒎𝒑𝒔 𝒐𝒗𝒆𝒓 𝒕𝒉𝒆 𝒍𝒂𝒛𝒚 𝒅𝒐𝒈",
	"𝓣𝓱𝓮 𝓺𝓾𝓲𝓬𝓴 𝓫𝓻𝓸𝔀𝓷 𝓯𝓸𝔁 𝓳𝓾𝓶𝓹𝓼 𝓸𝓿𝓮𝓻 𝓽𝓱𝓮 𝓵𝓪𝔃𝔂 𝓭𝓸𝓰","𝕋𝕙𝕖 𝕢𝕦𝕚𝕔𝕜 𝕓𝕣𝕠𝕨𝕟 𝕗𝕠𝕩 𝕛𝕦𝕞𝕡𝕤 𝕠𝕧𝕖𝕣 𝕥𝕙𝕖 𝕝𝕒𝕫𝕪 𝕕𝕠𝕘",
	"𝚃𝚑𝚎 𝚚𝚞𝚒𝚌𝚔 𝚋𝚛𝚘𝚠𝚗 𝚏𝚘𝚡 𝚓𝚞𝚖𝚙𝚜 𝚘𝚟𝚎𝚛 𝚝𝚑𝚎 𝚕𝚊𝚣𝚢 𝚍𝚘𝚐",
	"⒯⒣⒠ ⒬⒰⒤⒞⒦ ⒝⒭⒪⒲⒩ ⒡⒪⒳ ⒥⒰⒨⒫⒮ ⒪⒱⒠⒭ ⒯⒣⒠ ⒧⒜⒵⒴ ⒟⒪⒢",
	"1;DROP TABLE users","1'; DROP TABLE users-- 1","' OR 1=1 -- 1",
	"' OR '1'='1 ","%","_","-","--","--version","--help",
	"$USER","/dev/null; touch /tmp/blns.fail ; echo","`touch /tmp/blns.fail`","$(touch /tmp/blns.fail)",
	"$HOME","$ENV{'HOME'}","%d","%s","{0}","%*.*s","File:///",
	"../../../../../../../../../../../etc/passwd%00",
	"../../../../../../../../../../../etc/hosts",
	"() { 0; }; touch /tmp/blns.shellshock1.fail;",
	"() { _; } >_[$($())] { touch /tmp/blns.shellshock2.fail; }",
	"<<< %s(un='%s') = %u","+++ATH0","DCC SEND STARTKEYLOGGER 0 0 0",
	"Powerلُلُصّبُلُلصّبُررً ॣ ॣh ॣ ॣ冗","🏳0🌈️"]

    return random.choice(warm_fuzzies_from_blns)


def test_generate_user_token():
    """
    Just generate a junk authentication token for test purposes.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_application():
    """
    For identifying applications we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_application_fuzz():
    """
    Create fuzzing values for the Application ID. Things we'll
    vary:

        - outside of UUID character set
        - alternative formats
        - escapes
        - path walking

    :return:
    """

    # right now we'll just use hte BLNS fuzzing set
    return fuzzing_from_blns()


def test_parameter_resource():
    """
    For identifying resources, we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_sensor():
    """
    For identifying a specific sensor, we'll use a UUID for now.

    :return: String
    """
    return str(uuid.uuid4())


def test_parameter_username():
    """
    Generate a basic username.

    :return: String
    """
    return ".".join(random.sample("Aaden Alaysia Alfred Amia Annabell Anson Apollo Araceli Astrid Audrianna Augustine Avalyn Ayana Bayleigh Belinda Branden Brendon Brenton Broderick Brysen Camilo Camryn Castiel Charity Clyde Collins Corban Cristina Dalilah Darien Dario Davon Deegan Denzel Devyn Emmaline Ephraim Estelle Giovanna Graeme Grey Houston Immanuel India Ireland Jakobe Jaycob Jayde Jayse Jordy Judith Kaidence Kailani Kaiya Kalel Kannon Karissa Karly Karma Kaylyn Kenna Kohen Kylah Lachlan Langston Leroy Lillyana Magnolia Magnus Makena Marleigh Meadow Nahla Natalya Neriah Osvaldo Penny Pierre Princess Reagan Rihanna Rivka Rocky Rowen Roxanne Ryann Santana Sarahi Sidney Tamia Tess Thatcher Tinley Todd Truman Tyree Tyrell Yadiel Yair Zainab".split(" "), 2))


def test_parameter_since():
    """
    A time stamp as a filter value for the **since** parameter
    in a time based or time series query. Defaults to NOW

    :return: String
    """
    return datetime.datetime.now().isoformat()


def test_parameter_validate_action():
    """
    Action taken during sensor validation.

    :return: String
    """
    return random.choice(["canary", "cross-validation"])


def test_parameter_filter_level():
    """
    Filter level is used to control filtering of log messages. This
    value is from a set of default terms:

        ["everything", "debug", "info", "warning", "error", "event"]

    or from either of the terms:

        INC
        DEC

    :return:
    """
    return random.choice(["everything", "debug", "info", "warning", "error", "event"])


def test_parameter_follow():
    """
    Parameter for following (or not) a JSONL series from the log
    streamer.

    :return: True or False
    """
    return random.choice([True, False])


def test_parameter_action():
    """
    Our test parameters.

    :return: String
    """
    return random.choice(["validate", "invalidate"])


def test_parameter_cidr():
    """
    Build a test parameter value for a CIDR block. This needs to be an
    IP plus a suffix filter, like 8.0.0.0/27. We'll auto-escape the slash
    as %2F

    This will, for now, return a random IP in the range 2.0.0.0-240.0.0.0

    :return: IPv4 IP as a String
    """
    return "%d.%d.%d.%d%%2F%d" % (
        random.randint(2, 240),
        random.randint(1, 255),
        random.randint(1, 255),
        random.randint(2, 250),
        random.randint(8, 32)
    )


def test_parameter_address():
    """
    An address is a hostname or IPv4 address that describes a
    single host. We randomly select among these.

    :return: String address
    """
    if random.choice([1, 2]) == 1:
        # IPv4 it is
        return "%d.%d.%d.%d" % (
            random.randint(2, 240),
            random.randint(1, 255),
            random.randint(1, 255),
            random.randint(2, 250)
        )
    else:
        # Hostname. Let's make something AWS like
        return "ip-%d-%d-%d-%d.us-%s-%d.compute.internal" % (
            random.randint(2, 240),
            random.randint(1, 255),
            random.randint(1, 255),
            random.randint(2, 250),
            random.choice(["east", "west"]),
            random.randint(1,3)
        )


def test_parameter_virtue():
    """
    Generate a VirtueID, which is a UUID.

    :return: Random UUID as String
    """
    return str(uuid.uuid4())


def test_parameter_level():
    """
    Build a test parameter value for the LEVEL at which a sensor
    or group of sensors can observe. Will be one of:

        off, default, low, high, adversarial

    :return:
    """
    return random.choice("off default low high adversarial".split(" "))


def test_uri_has_parameters(uri):
    """
    Determine if the test URI has parameters we know how to parse and
    interpolate. This will throw an exception if we find a parameter
    we don't know how to deal with.

    Parameters in URIs look like:

        /path/to/:id/and/:another

    Where :id and :another are named parameters.

    :param uri:
    :return: True or False
    """
    bits = uri.split("/")
    while len(bits[0]) == 0:
        bits = bits[1:]

    params = [bit for bit in bits if bit[0] == ":"]

    if len(params) == 0:
        return False
    else:

        # make sure all of the params have known functions
        for param in params:
            try:
                param_func = "test_parameter_%s" % (param[1:],)
                eval(param_func)
            except NameError as ne:
                # it doesn't exist, let's throw an error here
                print("uri [%s] contains a named parameter we can't interpolate [%s]" % (uri, param))
                raise ne
        return True


def test_interpolate_uri_parameters(uri_path):
    """
    Build the test URI given possible parameters.

    :param uri: String path for the URI
    :return:
    """


    if test_uri_has_parameters(uri_path):
        selected_params = {}
        bits = uri_path.split("/")
        new_bits = []

        # clean off leading slashes
        while len(bits[0]) == 0:
            bits = bits[1:]

        # do interpolations
        for bit in bits:
            if bit[0] == ":":
                # we got a param!
                new_bits.append(test_interpolate_parameter(bit))
                selected_params[bit] = new_bits[-1]
            else:
                # not a param
                new_bits.append(bit)

        # rebuild the path
        return "/%s" % ("/".join(new_bits),), selected_params
    else:
        return uri_path, {}


def test_interpolate_parameter(bit):
    """
    Given a named parameter, built a real value for it. This uses
    the `test_parameter_*` functions to get a random value.

    :param bit: Named parameter starting with a ':'
    :return: Real value
    """
    func = eval("test_parameter_%s" % (bit[1:],))
    return func()


def test_interpolate_parameters(test):
    """
    Interpolate possible parameters for a GET based request. This uses
    any values in the *parameters* section of a test case, as well as
    testing for authentication. The return value is a dictionary of
    request parameters

    :param test: Test Case definition
    :return: Dictionary of parameters
    """
    tups = []

    if "authenticate" in test and test["authenticate"]:
        tups.append(("userToken", test_generate_user_token()))

    if "parameters" in test:
        for parameter in test["parameters"]:

            # try and find a test_parameter function for this value
            try:
                func = eval("test_parameter_%s" % (parameter,))
            except NameError as ne:
                print("TestCase has a parameter that we can't interpolate [%s]" % (parameter,))
                raise ne

            # add a value
            tups.append((parameter, func()))

    return {tup[0]: tup[1] for tup in tups}


def validate_isnt_error(results):
    """
    Validate that the given results have no errors.

    :param results: parsed JSON object
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "error": is_exactly(False),
        "timestamp": is_timestamp
    }

    return run_validation(results, check_for)


def validate_is_error(results):
    """
    Validate that the given results have the elements
    required for an error condition:

        error: True
        msg: String
        timestamp:

    :param results: parsed JSON object
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_exactly(True),
        "msg": is_string,
        "timestamp": is_timestamp
    }

    return run_validation(results, check_for)


def validate_stream_message(results):
    """
    Validate that our result contains a streaming log
    message, which has the fomr:

        {
            "error": False,
            "timestamp": timestamp,
            "log_level": one of ["everything", "debug", "info", "warning", "error", "event"],
            "sensor": uuid(),
            "message": log message
        }

    :param results: Parsed result of a single JSON line from a JSONL response from a /stream REST API call
    :return: List of errors, empty list if no errors
    """
    check_for = {
        "error": is_boolean,
        "timestamp": is_timestamp,
        "log_level": is_in("everything", "debug", "info", "warning", "error", "event"),
        "sensor": is_uuid,
        "message": is_string
    }

    return run_validation(results, check_for)


def validate_observe(results):
    """
    Validate the results form an /observe Sensing API
    call. The response object looks like:

        {
            "error": False,
            "level": sensing level,
            "timestamp": timestamp,
            "targeting": {},
            "actions": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "level": ( off | default | low | high | adversarial)
                },
                ...
            ]
        }

    :param results: Parsed results of /observe API call
    :return: List of errors, empty list if no errors
    """

    check_outer = {
        "error": is_boolean,
        "level": is_in("off", "default", "low", "high", "adversarial"),
        "timestamp": is_timestamp,
        "targeting": is_targeting
    }

    check_actions = {
        "sensor": is_uuid,
        "virtue": is_uuid,
        "level": is_in("off", "default", "low", "high", "adversarial")
    }

    errors = run_validation(results, check_outer)

    if "actions" in results:
        for action in results["actions"]:
            errors += run_validation(action, check_actions)
    else:
        errors.append("Missing [actions] in observe results")

    return errors


def validate_trust_invalidate(results):
    """
    Validate the results from a trust/invalidate Sensing API
    call. The response object looks like:

        {
            "error": False,
            "targeting": {},
            "timestamp": timestamp,
            "action": "invalidate",
            "invalidations": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "certificate": {
                        "cn": uuid,
                        "fingerprint": "08:3F:... 32 times"
                    }
                },
                ...
            ]
        }

    :param results: Parsed results of trust/invalidate API call
    :return: List of errors, emtpy list for no errors
    """
    errors = []

    check_for_outer = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp,
        "action": is_in("invalidate")
    }

    check_for_inner = {
        "sensor": is_uuid,
        "virtue": is_uuid
    }

    check_for_cert = {
        "cn": has_value,
        "fingerprint": is_fingerprint,
    }

    # check the outer block of results
    errors += run_validation(results, check_for_outer)

    # now check all the validations
    if "invalidations" in results:
        for validation in results["invalidations"]:

            # validation block
            errors += run_validation(validation, check_for_inner)

            # certificate block
            if "certificate" in validation:
                errors += run_validation(validation["certificate"], check_for_cert)
            else:
                errors.append("Invalidation is missing [certificate] data")
    else:
        errors.append("Missing [invalidations] in results")

    return errors


def validate_trust_validate(results):
    """
    Validate the results from a trust/validate Sensing API
    call. The response object looks like:

        {
            "error": False,
            "targeting": {},
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "action": "validate",
            "validations": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "certificate": {
                        "not_valid_before": timestamp,
                        "not_valid_after": timestamp,
                        "CN": "sensor-name-and-id",
                        "key_type": "RSA Public Key (4096 bit)",
                        "fingerprint": "08:3F:.... 32 octets",
                        "chain_of_trust": ["intermediate-cert-1", ... , "root-cert"]
                    }
                }
            ]
        }

    :param results: Parsed results from a trust/validate REST JSON response
    :return: List of errors, empty list for no errors
    """

    errors = []

    check_for_outer = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp,
        "action": is_in("validate")
    }

    check_for_inner = {
        "sensor": is_uuid,
        "virtue": is_uuid
    }

    check_for_cert = {
        "not_valid_before": is_timestamp,
        "not_valid_after": is_timestamp,
        "cn": has_value,
        "key_type": is_exactly("RSA Public Key (4096 bit)"),
        "fingerprint": is_fingerprint,
        "chain_of_trust": each_item(is_string)
    }

    # check the outer block of results
    errors += run_validation(results, check_for_outer)

    # now check all the validations
    if "validations" in results:
        for validation in results["validations"]:

            # validation block
            errors += run_validation(validation, check_for_inner)

            # certificate block
            if "certificate" in validation:
                errors += run_validation(validation["certificate"], check_for_cert)
            else:
                errors.append("Validation is missing [certificate] data")
    else:
        errors.append("Missing [validations] in results")

    return errors


def validate_inspect(results):
    """
    Validate the results from a sensor set inspection call. This
    targets zero or more sensors, and has a response that looks
    like:

        {
            "error": False,
            "targeting": {},
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "sensors": [
                {
                    "sensor": uuid,
                    "virtue": uuid,
                    "state": (active | inactive),
                    "name": string
                },
                ...
            ]
        }

    :param results: Parsed results from an /inspect REST JSON response
    :return: List of errors, empty list for no errors
    """

    # check the top level object
    check_for = {
        "error": is_boolean,
        "targeting": is_targeting,
        "timestamp": is_timestamp
    }

    errors = run_validation(results, check_for)

    # now get errors for any of the sensors
    sensor_check_for = {
        "sensor": is_uuid,
        "virtue": is_uuid,
        "state": is_in("active", "inactive"),
        "name": is_string
    }

    if "sensors" in results:
        for sensor in results["sensors"]:
            errors += run_validation(sensor, sensor_check_for)
    else:
        errors.append("No [sensor] data in inspect results")
    return errors


def validate_configure_review(results):
    """
    Validate the results from a configuration review
    call. This targets a specific sensor, and has
    a response that looks like:

        {
            "error": False,
            "sensor": uuid,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "configuration": {}
        }

    :param results: Parsed results from a configure/review REST JSON response
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_boolean,
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "configuration": is_dict
    }

    return run_validation(results, check_for)


def validate_configure_update(results):
    """
    Validate the results from a configuration update for
    a sensor. This targets a specific sensor, and has
    a response that looks like:

        {
            "error": False,
            "sensor": uuid,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "config_source": ( uri | base64 ),
            "msg": "ok"
        }

    :param results: Parse results from a configure/update REST JSON response
    :return: List of errors, empty list for no errors
    """

    check_for = {
        "error": is_boolean,
        "sensor": is_uuid,
        "timestamp": is_timestamp,
        "config_source": is_in("uri", "base64"),
        "msg": is_in("ok")
    }

    return run_validation(results, check_for)


def validate_trigger_validation(results):
    """
    Validate the results from triggering a _validate/trigger_ call
    into the Sensing API. The results will look something like:

        {
            "error": False,
            "timestamp": "YYYY-MM-DD HH:MM:SS.mmmmmmZ",
            "token": uuid,
            "validation": <cross-validate || canary-validate>,
            "virtues": [ ... uuid ...]
        }

    :param results: Parsed results from a */validate/:action REST JSON response
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "error": is_boolean,
        "timestamp": is_timestamp,
        "token": is_uuid,
        "validation": is_in("canary-validate", "cross-validate"),
        "virtues": each_item(is_uuid),
        "targeting": is_targeting
    }

    return run_validation(results, check_for)


def validate_sensor_validation_list(results):
    """
    Validate the list of sensors as returned from a _validate/check_ call
    into the Sensing API. The results will look something like:

        {
            "timestamp": "",
            "error": False,
            "targeting": {},
            "sensors": [
                {
                    "virtue": uuid,
                    "sensor": uuid,
                    "name": "",
                    "last-validated": "2017-10-31 20:40:28.190581Z",
                    "compromised": False,
                    "cross-validation": {},
                    "canary-validation": {}
                }
            ]
        }

    We're interested in the individual sensors.

    :param results: Parsed results from */validate/check REST JSON response
    :return: List of errors, empty list for no errors
    """
    # validate the sensor list
    errors = []
    if "sensors" in results:
        for sensor in results["sensors"]:
            errs = validate_sensor_validation(sensor)
            errors += errs
    else:
        errors.append("[sensors] key missing")

    # validate the top level object
    check_for = {
        "timestamp": is_timestamp,
        "error": is_boolean,
        "targeting": is_targeting
    }

    errors += run_validation(results, check_for)

    return errors


def validate_sensor_validation(sensor):
    """
    Validate a sensor data blob as received from a _validate/check_ call
    into the Sensing API. An individual sensor will look something like:

        {
            "virtue": uuid,
            "sensor": uuid,
            "name": "",
            "last-validated": "2017-10-31 20:40:28.190581Z",
            "compromised": False,
            "cross-validation": {},
            "canary-validation": {}
        }

    :param sensor: Individual sensor blob as parsed from */validate/check REST JSON response
    :return: List of errors, empty list for no errors
    """
    check_for = {
        "virtue": is_uuid,
        "sensor": is_uuid,
        "name": has_value,
        "last-validated": is_timestamp,
        "last-validation-token": is_uuid,
        "compromised": is_boolean,
        "cross-validation": is_dict,
        "canary-validation": is_dict
    }

    return run_validation(sensor, check_for)


def run_validation(object, validation):
    """
    Run a 'check_for' validation on an object, which will make sure that
    keys exist in an object, and the values of those keys are the proper
    values.

    A 'check_for' dictionary looks like:

        {
            "key": <is_* function> | <lambda returning boolean>,
            ...
        }

    :param object: A dictionary object
    :param validation: A 'check_for' dictionary
    :return: List of errors, empty list for no errors
    """
    errors = []

    for k, v in validation.items():

        if k in object:
            if v(object[k]):
                # we're good!
                pass
            else:
                errors.append("Value for key [%s] failed validation function [%s]" % (k, v.__name__))
        else:
            errors.append("Missing key [%s]" % (k,))
    return errors


def each_item(v_func):
    """
    Build a function that evaluates a list against a validation
    function. Given a list of booleans to evaluate, this should
    be called like:

        each_item(is_boolean)

    :param v_func: function for validation of items in list
    :return: Validation function to verify a list
    """

    def each_item_inner(l):
        for i in l:
            if not v_func(i):
                return False
        return True

    return each_item_inner


def is_fingerprint(v):
    """
    Make sure the given value is a 32 block hex fingerprint.

    :param v: candidate value
    :return: boolean
    """

    return re.match(r'^([0-9a-fA-F]{2}\:){31}([0-9a-fA-F]{2})$', v) is not None


def is_string(s):
    """
    Make sure the value is a string type.

    :param s: value to test
    :return:  boolean
    """
    return type(s) == type("hello")


def is_in(*kargs, **kwargs):
    """
    Make sure a value is in a given list of values (contained
    in the kargs. This should be called like:

        is_in(1, 2, 3)

    And will return a validation function.

    :param kargs: values in the set
    :return: validation function to verify a value in a set
    """

    def is_in_inner(val):
        return val in kargs

    return is_in_inner


def is_targeting(d):
    """
    Make sure the data in the provided dictionary is targeting
    key value pairs, and doesn't have extraneous data.

    Acceptable targeting keys:

        - cidr
        - virtue
        - username
        - address
        - application
        - resource
        - sensor

    :param d: candidate targeting dictionary
    :return: boolean
    """
    acceptable = set("cidr virtue username address application resource sensor".split(" "))

    for k in d.keys():
        if k not in acceptable:
            return False
    return True


def is_timestamp(str):
    """
    Make sure the string contains a timestamp that conforms
    to our expected time format of:

        2017-10-31 20:40:28.190581Z

    :param str: Possible time stamp
    :return: boolean
    """

    if str is None:
        return False
    try:
        datetime.datetime.strptime(str, "%Y-%m-%d %H:%M:%S.%fZ")
        return True
    except ValueError as ve:
        return False


def is_boolean(v):
    """
    Make sure the value V is a boolean.

    :param v: candidate value
    :return: boolean
    """
    return type(v) == type(False)


def is_dict(d):
    """
    Make sure the given value is a dictionary object.

    :param d:
    :return:
    """
    return type(d) == type({})


def is_exactly(v):
    """
    Create an exact comparator function.

    :param v: Value to compare against
    :return: boolean
    """

    def is_exactly_inner(c):
        return c == v

    return is_exactly_inner


def has_value(str):
    """
    Basically a nop, make sure the str isn't None
    :param str:
    :return:
    """
    return str != None


def is_uuid(str):
    """
    Is the given string a valid UUID?

    :param str: String or None
    :return: boolean
    """
    if str is None:
        return False
    else:
        return re.match(r'^[a-zA-Z0-9]{8}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{4}\-[a-zA-Z0-9]{12}$', str) is not None


def test_case(opts, test, repeat=5):
    """
    Run an individual test one or more times. A list of status dictionaries
    is returned with an entry for each iteration of the test. The dictionary
    looks like:

        {
            "pass": <True | False>,
            "parameters": {
                ":variable": "selected value"
            },
            "returns": {
                "expected": "JSON",
                "got": "cannot parse...."
            },
            "code": {
                "expected": 501,
                "got": 200
            },
            "result_has_fields": {
                "field name": "representative type for result"
            },
            "request_body": {
                "key to insert into request body": "value for key"
            },
            "results_validators": {
                "key": <validation function>
            }
        }

    :param opts: Command configuration options
    :param test: Test case as defined in the *test_api* method
    :param repeat: Number of variations of the test to run, if interpolated parameters exist
    :return: Test results list
    """
    results = []

    # force repeat to one if we don't have variable params
    if not test_uri_has_parameters(test["path"]):
        repeat = 1

    # let's rock this joint
    for rep in range(repeat):

        # start building our result object
        rep_result = {
            "returns": {
                "expected": test["returns"],
                "got": ""
            },
            "code": {
                "expected": test["code"],
                "got": 0
            },
            "pass": False,
            "parameters": {}
        }

        # build a URI
        uri_path, selected_params = test_interpolate_uri_parameters(test["path"])
        full_uri = construct_api_uri(opts, uri_path)

        # record the randomized parameters
        rep_result["parameters"] = selected_params

        # construct request
        #  but first, are we authenticating?
        if "authenticate" in test and test["authenticate"]:
            if test["method"].lower() == "get":
                # determine any parameters for our get request
                get_params = test_interpolate_parameters(test)

                # fire away
                res = getattr(requests, test["method"].lower())(full_uri, params=get_params)
            else:

                # generate the request body payload
                request_body = {"userToken": test_generate_user_token()}
                if "request_body" in test:
                    for k, v in test["request_body"].items():
                        request_body[k] = v

                res = getattr(requests, test["method"].lower())(full_uri, data=request_body)
        else:
            if test["method"].lower() == "get":

                # determine any parameters for our get request
                get_params = test_interpolate_parameters(test)

                # fire away
                res = getattr(requests, test["method"].lower())(full_uri, params=get_params)
            else:

                # generate the request body payload
                request_body = {}
                if "request_body" in test:
                    for k, v in test["request_body"].items():
                        request_body[k] = v

                res = getattr(requests, test["method"].lower())(full_uri)

        # check results
        did_pass = True

        # make sure we got the status code we expected
        rep_result["code"]["got"] = res.status_code
        if res.status_code != test["code"]:
            did_pass = False

        # make sure we got JSON or JSONL if that's what we expected, and then
        # verify the data from the results
        rep_result["returns"]["got"] = res.text
        if test["returns"].lower() == "json":
            try:

                # did we get JSON?
                res_json = res.json()
                rep_result["returns"]["got"] = "JSON"
                rep_result["result"] = res_json

                # validate from our result_has_fields, which looks like:
                #
                #       {
                #           "key": value,
                #           "key": value,
                #           ...
                #       }
                #
                # Which we use to validate in multiple ways:
                #   - key must exist
                #   - type of key in results must match type in result_has_fields
                if "result_has_fields" in test:
                    rep_result["result_has_fields"] = []
                    for key in test["result_has_fields"].keys():

                        # key exists
                        if key not in res_json:
                            rep_result["result_has_fields"].append("The [%s] key is missing from the results" % (key,))
                            did_pass = False

                        # types match
                        if key in res_json:
                            if type(test["result_has_fields"][key]) != type(res_json[key]):
                                rep_result["result_has_fields"].append(
                                    "The field [%s] in the results has the wrong type. Expected (%s) got (%s)" %
                                    (
                                        key,
                                        type(test["result_has_fields"][key]),
                                        type(res_json[key])
                                    )
                                )

                # Run any results_validators we have, which do deep value inspection
                if "results_validators" in test:
                    rep_result["results_validators"] = {}

                    # run the individual validators
                    for res_validator in test["results_validators"]:

                        # grab errors and keep them
                        errors = res_validator(res_json)
                        rep_result["results_validators"][res_validator.__name__] = errors

                        # anything other than 0 errors is a fail case
                        if len(errors) > 0:
                            did_pass = False

            except Exception as e:
                print(e)
                rep_result["returns"]["got"] = str(e)
                rep_result["returns"]["raw"] = res.text
                did_pass = False
        elif test["returns"].lower() == "jsonl":

            # we're going to start by splitting our response on newlines
            responses = res.text.split("\n")

            for res_line in responses:

                # skip over the blank lines
                if res_line.strip() == "":
                    continue

                try:

                    # did we get JSON?
                    res_json = json.loads(res_line)

                    rep_result["returns"]["got"] = "JSON"
                    rep_result["result"] = res_json

                    # validate from our result_has_fields, which looks like:
                    #
                    #       {
                    #           "key": value,
                    #           "key": value,
                    #           ...
                    #       }
                    #
                    # Which we use to validate in multiple ways:
                    #   - key must exist
                    #   - type of key in results must match type in result_has_fields
                    if "result_has_fields" in test:
                        rep_result["result_has_fields"] = []
                        for key in test["result_has_fields"].keys():

                            # key exists
                            if key not in res_json:
                                rep_result["result_has_fields"].append(
                                    "The [%s] key is missing from the results" % (key,))
                                did_pass = False

                            # types match
                            if key in res_json:
                                if type(test["result_has_fields"][key]) != type(res_json[key]):
                                    rep_result["result_has_fields"].append(
                                        "The field [%s] in the results has the wrong type. Expected (%s) got (%s)" %
                                        (
                                            key,
                                            type(test["result_has_fields"][key]),
                                            type(res_json[key])
                                        )
                                    )

                    # Run any results_validators we have, which do deep value inspection
                    if "results_validators" in test:
                        rep_result["results_validators"] = {}

                        # run the individual validators
                        for res_validator in test["results_validators"]:

                            # grab errors and keep them
                            errors = res_validator(res_json)
                            rep_result["results_validators"][res_validator.__name__] = errors

                            # anything other than 0 errors is a fail case
                            if len(errors) > 0:
                                did_pass = False

                except Exception as e:
                    print(e)
                    rep_result["returns"]["got"] = str(e)
                    rep_result["returns"]["raw"] = res.text
                    did_pass = False

        rep_result["pass"] = did_pass

        # build test case evaluation
        results.append(rep_result)

    return results


def construct_api_uri(opts, uri_path):
    """
    Build a full URI for a request to the API.

    :param opts: Command configuration options
    :param uri_path: Full path for the API
    :return: String URI
    """

    # setup the host
    host = opts.api_host

    if not host.startswith("http"):
        host = "http://%s" % (host,)

    # setup the full uri
    return "%s:%d/api/%s%s" % (host, opts.api_port, opts.api_version, uri_path)


def test_generate_unauthenticated_tests(tests):
    """
    Given the existing body of tests, generate a set
    of unauthenticated tests for any existing tests that
    require authentication. Rewrite the conditions for this
    test to expect HTTP 401, and a results_validator of validate_is_error.

    :param tests: Existing body of tests
    :return: List of test cases
    """

    new_tests = []

    for test in tests:

        # generate unauthenticated test cases
        if test["authenticate"] == True:

            new_test = {}

            # copy the current test
            for k,v in test.items():
                new_test[k] = v

            # no longer authenticate
            new_test["authenticate"] = False

            # HTTP 401
            new_test["code"] = 401

            # result validators
            new_test["results_validators"] = [validate_is_error]

            # remove any "result_has_fields" tests
            new_test["result_has_fields"] = {}

            new_tests.append(new_test)

    return new_tests


def test_api(opts):
    """
    Test the virtue-security backend API.

    Each test is defined as a dictionary that looks like:

        {
            "path": "/path/to/command/:variable/",
            "method": "PUT",
            "returns": "JSON",
            "code": 501
        }

    Where:

        - *path* can define one or more variable parameters that will
          be interpreted at run time and filled in over the series
          of tests.
        - *method* is one of GET, PUT, POST, or DELETE
        - *expect* is one of JSON, NONE
        - *code* is a valid HTTP status code

    :param opts: Command configuration options
    :return:
    """

    tests = [

        # NETWORK API

        # === Observe
        {
            "method": "PUT",
            "path": "/network/:cidr/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/network/:cidr/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/network/:cidr/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        # todo: JSONL returns

        {
            "method": "GET",
            "path": "/network/:cidr/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/network/:cidr/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/network/:cidr/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/network/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/network/:cidr/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/network/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases
        {
            "method": "GET",
            "path": "/network/not_a_cidr/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "results_validators": [validate_is_error]
        },
        {
            "method": "PUT",
            "path": "/network/not_a_cidr/validate/:validate_action",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "results_validators": [validate_is_error]
        },

        # VIRTUE API

        # === Observe
        {
            "method": "PUT",
            "path": "/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # VIRTUAL MACHINE API

        # === Observe
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/vm/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/vm/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/vm/address/:address/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/vm/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/vm/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/vm/address/:address/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases
        {
            "method": "GET",
            "path": "/vm/address/300.300.300.300/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },
        {
            "method": "GET",
            "path": "/vm/address/not{real{hostname/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        # APPLICATION API
        #   Note for application targeting, we use a combinator of filters, which can be used
        #   singularly, or in ordered combinations to allow fine grained target selection.
        #   See the Sensing API documentation for more details. This is why we see more variations
        #   of possible call paths for Application vs any other selectors.


        # === Observe
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },


        # === Stream
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/virtue/:virtue/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/application/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },

        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/virtue/:virtue/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/application/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # RESOURCE API
        #   Like the Application API, some of the interactions with the Resource API use a combinator
        #   approach for targeting. See the Sensing API document for more information.

        # === Observe
        {
            "method": "PUT",
            "path": "/resource/:resource/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/resource/:resource/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/resource/:resource/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },


        # === Stream
        {
            "method": "GET",
            "path": "/resource/:resource/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # == Inspect
        {
            "method": "GET",
            "path": "/resource/:resource/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/resource/:resource/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "GET",
            "path": "/resource/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },

        {
            "method": "PUT",
            "path": "/resource/:resource/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/virtue/:virtue/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },
        {
            "method": "PUT",
            "path": "/resource/user/:username/application/:application/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # --- Failure Cases

        #       invalid resource id
        {
            "method": "GET",
            "path": "/resource/123123123123/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue id
        {
            "method": "GET",
            "path": "/resource/virtue/123456789/user/:username/application/:application/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application id
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/user/:username/application/123456789/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue ID
        {
            "method": "GET",
            "path": "/resource/virtue/12334346456/user/:username/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid virtue ID
        {
            "method": "GET",
            "path": "/resource/virtue/123456789/application/:application/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application ID
        {
            "method": "GET",
            "path": "/resource/virtue/:virtue/application/123456789/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #       invalid application ID
        {
            "method": "GET",
            "path": "/resource/user/:username/application/123456798/validate/check",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        # USER API

        # === Observe
        {
            "method": "PUT",
            "path": "/user/:username/observe/:level",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_observe]
        },

        # === Trust
        {
            "method": "PUT",
            "path": "/user/:username/trust/validate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_validate]
        },

        {
            "method": "PUT",
            "path": "/user/:username/trust/invalidate",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trust_invalidate]
        },

        # === Stream
        {
            "method": "GET",
            "path": "/user/:username/stream",
            "returns": "JSONL",
            "code": 200,
            "authenticate": True,
            "parameters": ["since", "filter_level", "follow"],
            "results_validators": [validate_stream_message]
        },

        # === Inspect
        {
            "method": "GET",
            "path": "/user/:username/inspect",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_inspect]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/user/:username/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/user/:username/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # SENSOR API

        # === Configure
        {
            "method": "GET",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "configuration": {}
            },
            "results_validators": [validate_configure_review]
        },

        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "request_body": {
                "configuration": "http://resource.twosixlabs.com/path/to/something"
            },
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "config_source": "",
                "msg": ""
            },
            "results_validators": [validate_configure_update]
        },

        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "request_body": {
                "configuration": "dHdvc2l4bGFicw=="
            },
            "result_has_fields": {
                "error": False,
                "sensor": "",
                "timestamp": "",
                "config_source": "",
                "msg": ""
            },
            "results_validators": [validate_configure_update]
        },

        # --- Failure Cases

        #     Invalid Sensor ID
        {
            "method": "GET",
            "path": "/sensor/1324567654323456/configure",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Unauthenticated
        {
            "method": "GET",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 401,
            "authenticate": False,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Missing configuration payload
        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 400,
            "authenticate": True,
            "result_has_fields": {
                "error": True,
                "msg": "",
                "timestamp": ""
            },
            "results_validators": [validate_is_error]
        },

        #     Unauthenticated
        {
            "method": "PUT",
            "path": "/sensor/:sensor/configure",
            "returns": "JSON",
            "code": 401,
            "authenticate": False,
            "result_has_fields": {
                "error": True,
                "msg": ""
            },
            "results_validators": [validate_is_error]
        },

        # === Validate
        {
            "method": "GET",
            "path": "/sensor/:sensor/validate/check",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_sensor_validation_list]
        },
        {
            "method": "PUT",
            "path": "/sensor/:sensor/validate/:validate_action",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_trigger_validation]
        },

        # ENUM API
        {
            "method": "GET",
            "path": "/enum/observation/levels",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_isnt_error]
        },
        {
            "method": "GET",
            "path": "/enum/log/levels",
            "returns": "JSON",
            "code": 200,
            "authenticate": True,
            "results_validators": [validate_isnt_error]
        },

    ]

    # generate unauthenticated tests
    if opts.test_unauthenticated:
        tests += test_generate_unauthenticated_tests(tests)

    print("virtue-security/test - running API endpoint response tests")
    print("  :: %d tests available" % (len(tests),))

    # apply our test filter
    tests = [t for t in tests if t["path"].startswith(opts.test_path)]
    print("  :: %d tests matching --test-path filter" % (len(tests),))

    # track pass/fail totals
    total_pass = 0
    total_fail = 0
    fail_codes = {}
    fail_paths = set()

    # track how many of the tests included run_validators
    total_with_results_validators = 0

    # temporarily track NOT IMPLEMENTED code 501 returns
    total_not_implemented = 0

    # now run the individual tests
    for test in tests:

        print("\t%(method)s %(path)s" % test)

        # run the test and record the results
        results = test_case(opts, test)

        passes = len([t for t in results if t["pass"]])
        fails = len(results) - passes

        total_fail += fails
        total_pass += passes

        # with what status codes did we fail?
        for test_result in results:

            # track test failures by a few different means for reporting
            if not test_result["pass"]:

                # store the path we failed
                fail_paths.add("%(method)s %(path)s" % test)

                # store the failure codes for later use
                fail_code = test_result["code"]["got"]
                if fail_code not in fail_codes:
                    fail_codes[fail_code] = 0

                fail_codes[fail_code] += 1

            # track 501s
            if test_result["code"]["got"] == 501:
                total_not_implemented += 1

        # were there results_validators run for these tests?
        if "results_validators" in test:
            if len(test["results_validators"]) > 0:
                total_with_results_validators += 1

        # report on what passed/failed
        print("\t\t%d/%d passed" % (passes, len(results)))

        # if we had failures, we dump the results
        if fails > 0:
            print(json.dumps(results, indent=4))

    # summary report
    print("  :: TEST SUMMARY")
    print(
"""
  :: %(passed)d passed, %(failed)d failed out of %(total)d total tests
       %(percent_pass)0.2f%% pass rate
       %(percent_with_validators)0.2f%% validator coverage
       %(test_cases)d test cases
       %(test_cases_with_validators)d test cases with results validators
""" %
        {
            "passed": total_pass,
            "failed": total_fail,
            "total": total_pass + total_fail,
            "percent_pass": (total_pass * 1.0) / ( (total_pass + total_fail) * 1.0) * 100.0,
            "test_cases": len(tests),
            "test_cases_with_validators": total_with_results_validators,
            "percent_with_validators": (total_with_results_validators * 1.0) / (len(tests) * 1.0) * 100.0
        }
    )

    # report on NOT IMPLEMENTED returns
    if total_not_implemented > 0:
        print("\tHTTP(501) - not implemented results: %d" % (total_not_implemented,))

    # report on failure codes if we had any
    if len(fail_codes) > 0:
        print("    HTTP status_code for failures")
        for fail_code in sorted(fail_codes.keys()):
            print("      %d == %d" % (fail_code, fail_codes[fail_code]))

    # report on which unique paths failed
    if len(fail_paths) > 0:
        print("    Failed paths")
        for fail_path in list(fail_paths):
            print("      %s" % (fail_path,))


def api_version(opts):
    """
    Report on the version of the CLI utility and the running
    Sensing API if we can reach it.

    :param opts:
    :return:
    """
    print("virtue-security(version=%s)" % (__VERSION__,))

    # we need to custom code the conversion of the API endpoint to a full
    # URI because the version function sits outside of the semantic versioned
    # endpoint heirarchy

    # setup the host
    host = opts.api_host

    if not host.startswith("http"):
        host = "http://%s" % (host,)

    # setup the full uri
    uri = "%s:%d/version" % (host, opts.api_port)

    try:
        res = requests.get(uri)
        api_json = res.json()
        print("sensing-api(version=%s)" % (api_json["version"],))
    except requests.exceptions.Timeout as ret:
        print("-- timeout error connected to Sensing API (%s)" % (uri,))
    except ValueError as ve:
        print(ve)


def options():
    """
    Parse out the command line options.

    :return:
    """
    parser = argparse.ArgumentParser(description="Interact with the SAVIOR VirtUE security API")

    # top level control
    parser.add_argument("mode", metavar="M", help="Top level interaction", choices=["test", "version"])
    #parser.add_argument("sub_mode", metavar="S", help="Next level interaction", choices=[""])

    # identification variables
    parser.add_argument("--network", dest="var_network", default=None, help="Network or IP in CIDR format")
    parser.add_argument("--virtue-id", dest="var_virtue", default=None, help="Virtue ID")

    # sensor control states
    parser.add_argument("--level", dest="observation_level", default="off", help="Observation level")
    parser.add_argument("--action", dest="trust_action", default="invalidate", help="Validate or invalidate trust",
                        choices=["validate", "invalidate"])
    parser.add_argument("--filter-log-level", dest="log_level", default="everything",
                        help="Log level below which to filter out messages",
                        choices=["everything", "debug", "info", "warning", "error", "event"])

    parser.add_argument("--since", dest="time_since", default=None, help="Time or timestamp in log history")
    parser.add_argument("--follow", dest="log_follow", default=False, action="store_true", help="Follow the log stream")

    # communications
    parser.add_argument("-a", "--api-host", dest="api_host", default="localhost", help="API host URI")
    parser.add_argument("-p", "--api-port", dest="api_port", default=4000, type=int, help="API host port")
    parser.add_argument("--api-version", dest="api_version", default="v1", help="API version being called")

    # for API testing
    parser.add_argument("--test-path", dest="test_path", default="/", help="Filter prefix for selecting tests. Defaults to selecting all tests")
    parser.add_argument("--skip-unauthenticated-tests", dest="test_unauthenticated", default=True, action="store_false", help="Skip the generation of un-authenticated tests")

    return parser.parse_args()


if __name__ == "__main__":
    # print("virtue-security(version=%s)" % (__VERSION__,))

    opts = options()

    # dispatch our command based upon the primary mode
    dispatch = {
        "test": test_api,
        "version": api_version
    }

    if opts.mode not in dispatch:
        print("There is no [%s] mode, please try again, or use the --help flag" % (opts.mode,))
        sys.exit(1)

    dispatch[opts.mode](opts)

