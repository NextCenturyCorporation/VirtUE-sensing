
defmodule ApiServer.DatabaseUtils do
  @moduledoc """

  General utilities and helpers for working with the
  storage, query, and retrieval of sensors metadata.

  The database being used is defined in `web/models/database.ex`,
  and is a disk backed :mnesia database.

  A utility Struct for Sensor objects is defined in:
  `web/models/sensor.ex`.
  """
  import UUID, only: [uuid4: 0]
  alias :mnesia, as: Mnesia

  def deregister_sensor(
        %Sensor{
          :sensor => sensor,
          :public_key => public_key
        }
      )
    do

    # remove any records matching this sensor ID, if we can
    # validate that the sensor ID and public key match
    case Mnesia.transaction(
      fn ->
        case Mnesia.match_object(
          {
            Sensor,
            :_,
            sensor,
            :_, :_, :_, :_, :_,
            public_key
          }
        ) do

          # no matches
          [] ->
            {:ok, 0}

          # records to remove
          records ->
            Enum.map(records,
                fn (rec) ->
                  Mnesia.delete_object(rec)
                end
            )
            {:ok, length(records)}
        end
      end
    ) do
      {:atomic, {:ok, remove_count}} ->
        {:ok, remove_count}
      {:atomic, {:aborted, reason}} ->
        {:error, "deregistration aborted: #{reason}"}
    end
  end

  @doc """
  Register sensors to the database. Fields that aren't
  yet defined will be autogenerated or nil'ed by the
  registration method.

  Returns :mnesia transaction result

    {:atomic,
  """
  def register_sensor(
        %Sensor{
          :sensor => sensor,
          :virtue => virtue,
          :username => username,
          :address => address,
          :timestamp => nil,
          :port => port,
          :public_key => public_key
        })
    do

    # simple insert, create the timestamp on the fly
    case Mnesia.transaction(
      fn ->
        Mnesia.write(
          {
            Sensor,
            uuid4(),
            sensor,
            virtue,
            username,
            address,
            DateTime.to_string(DateTime.utc_now()),
            as_intger(port),
            public_key
          }
        )
      end
    ) do
      {:atomic, :ok} ->
        {:ok}
      {:atomic, {:aborted, reason}} ->
        {:error, "registration aborted: #{reason}"}
    end
  end

  def register_sensor(
        %Sensor{
          :sensor => sensor,
          :virtue => virtue,
          :username => username,
          :address => address,
          :timestamp => timestamp,
          :port => port,
          :public_key => public_key
        })
    do

    # simple insert
    case Mnesia.transaction(
      fn ->
        Mnesia.write(
          {
            Sensor,
            uuid4(),
            sensor,
            virtue,
            username,
            address,
            timestamp,
            as_intger(port),
            public_key
          }
        )
      end
    ) do
      {:atomic, :ok} ->
        {:ok}
      {:atomic, {:aborted, reason}} ->
        {:error, "registration aborted: #{reason}"}
    end
  end



  @doc """
  Retrieve the sensor address (hostname and port) using a
  sensor ID.

  Returns:

    {:ok, {:sensor => sensor_id, :addresss => hostname, :port => host port}
    {:error, reason}
  """
  def address_for_sensor(%{:sensor => sensor}) do

    Mnesia.transaction(
      fn ->
        case Mnesia.index_read(Sensor, sensor, :sensor) do
          {:atomic, []} ->
            {:error, "no sensor registered with id=#{sensor}"}
          {:atomic, payload} ->
            {:ok, address_for_sensor(List.first(payload))}
        end
      end
    )
  end

  @doc """
  Retrieve the list of sensors and addresses using any
  of the non :sensor_id indexed fields.

  Indexed fields include:

    - virtue_id
    - username
    - address

  Returns:

    {:ok, [{:sensor => "id", :address => "hostname", :port => "port"}, ...]}
    {:error, reason}
  """
  def addresses_for_sensor(%{:virtue => virtue}) do
    addresses_for_key(:virtue_id, virtue)
  end

  def addresses_for_sensor(%{:username => username}) do
    addresses_for_key(:username, username)
  end

  def addresses_for_sensor(%{:address => address}) do
    addresses_for_key(:address, address)
  end

  # Given a key (like :virtue_id) and a value (like a UUID), retrieve
  # all of the sensor addresses that match the k:v query in the
  # database.
  defp addresses_for_key(k, v) do
    Mnesia.transaction(
      fn ->
        case Mnesia.index_read(Sensor, v, k) do
          {:atomic, []} ->
            {:error, "no sensors found for #{k}=#{v}"}
          {:atomic, payload} ->
            {
              :ok,
              Enum.map(payload,
                fn (rec) ->
                  address_from_record(rec)
                end
              )
            }
        end
      end
    )
  end

  # Given an :mnesia record, retrieve the address field
  #
  defp address_from_record(rec) do
    %{
      :sensor => elem(rec, index_for_key(:sensor_id)),
      :address => elem(rec, index_for_key(:address)),
      :port => elem(rec, index_for_key(:port))
    }
  end

  # Interpolate a key into our record position
  defp index_for_key(k) do
    Enum.find(
      [:id, :sensor_id, :virtue_id, :username, :address, :timestamp, :port, :public_key],
      fn(x) ->
        x == k
      end
    )
  end

  # Make sure our value is an integer
  #
  defp as_intger(p) when is_integer(p) do
    p
  end

  defp as_intger(p) when is_bitstring(p) do
    elem(Integer.parse(p), 0)
  end
end